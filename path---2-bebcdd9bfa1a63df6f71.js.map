{"version":3,"sources":["webpack:///path---2-bebcdd9bfa1a63df6f71.js","webpack:///./.cache/json/2.json"],"names":["webpackJsonp","./node_modules/json-loader/index.js!./.cache/json/2.json","module","exports","data","allMarkdownRemark","edges","node","fields","slug","frontmatter","title","date","tags","release","html","pathContext","offset","paginations","total"],"mappings":"AAAAA,cAAc,iBAERC,2DACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,mBAAqBC,QAAUC,MAAQC,QAAUC,KAAA,2BAAiCC,aAAgBC,MAAA,gCAAAC,KAAA,mBAAAC,MAAA,kCAAAC,SAAA,GAA2HC,KAAA,iqDAA+qDR,MAAQC,QAAUC,KAAA,8BAAoCC,aAAgBC,MAAA,wBAAAC,KAAA,mBAAAC,MAAA,gCAAAC,SAAA,GAAiHC,KAAA,q6LAAkqMR,MAAQC,QAAUC,KAAA,qCAA2CC,aAAgBC,MAAA,0BAAAC,KAAA,mBAAAC,MAAA,sBAAAC,SAAA,GAAyGC,KAAA,8kCAA0lCR,MAAQC,QAAUC,KAAA,0BAAgCC,aAAgBC,MAAA,sBAAAC,KAAA,mBAAAC,MAAA,sBAAAC,SAAA,GAAqGC,KAAA,6xEAA22ER,MAAQC,QAAUC,KAAA,sBAA4BC,aAAgBC,MAAA,mBAAAC,KAAA,mBAAAC,MAAA,QAAAC,SAAA,GAAoFC,KAAA,iEAAwEC,aAAgBC,OAAA,GAAAC,YAAA,EAAAC,MAAA","file":"path---2-bebcdd9bfa1a63df6f71.js","sourcesContent":["webpackJsonp([157285553617042],{\n\n/***/ \"./node_modules/json-loader/index.js!./.cache/json/2.json\":\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"allMarkdownRemark\":{\"edges\":[{\"node\":{\"fields\":{\"slug\":\"/posts/session_n_token/\"},\"frontmatter\":{\"title\":\"SPA, Session vs Token-based認證\",\"date\":\"2017-08-12T19:07\",\"tags\":[\"Session\",\"REST\",\"Authorization\"],\"release\":true},\"html\":\"<p>進入了SPA的世界中，這算是目前前端的趨勢。以前都沒有寫過SPA，SPA的好處在網路上寫了很多，我個人認知的就是更好的UX，使用起來更像native，\\n另外就是很好的前後端分離，讓後端更著重在model的部分。不過介紹SPA不是這篇文章的重點，就不多贅述。</p>\\n<p>原本是想寫Oauth在SPA的一些處理心得，但是爬一爬文章就寫了一下Session與Token-based認證的比較。</p>\\n<p>先介紹State<br/>\\n中文直譯就是狀態，在react裡面也有用到，代表的就是UI的狀態，譬如說isOpenNav...，而這邊所提的是HTTP的狀態，HTTP屬於stateless的協定，\\n簡單分類的話就是伺服器會不會記得你所做的事情，假設你在網站中修改了個人檔案的姓名發送request，然後接著修改個人檔案的大頭貼另外又發送一個request，\\n兩個request之間沒有任何關係，server也不會記得每個request你做了什麼，這樣就屬於一種stateless。</p>\\n<p>Session<br/>\\n具有狀態性(Stateful)，由於Session是你與server的連線紀錄，儲存在server端。</p>\\n<h3>Session儲存的缺點</h3>\\n<ul>\\n<li>\\n<p>scalable較麻煩<br/>\\n試想若是後端有做loadbalance的機制，第一次進入登入頁面被導入server1，登入後Session儲存在server1，結果進入頁面後按了某個功能被導到server2，\\n但此server沒有你的Session就可能重新回到登入頁面，當然有一些其他的解決方案(Redis等...)</p>\\n</li>\\n<li>\\n<p>CORS問題<br/>\\n若是使用Session則通常你的client與server要設在同一個domain或sub domain(因為你可能要在cookie裡面傳送東西，cross domain不好處理)，\\n例如app.example.com的網頁，發送請求給api.example.com的server，但若是使用token-based，則可以很好的解決這個問題(因為user data會隨著http header而非cookie)</p>\\n</li>\\n</ul>\\n<h3>Token-based的好處</h3>\\n<ul>\\n<li>\\n<p>低耦合性 &#x26; Stateless<br/>\\n不需要將你的認證綁住server端，只要有一組token，每個server，每個api都可以使用。並且屬於無狀態性，要做scalable很容易，大家都使用統一的token。</p>\\n</li>\\n<li>\\n<p>Mobile friendly &#x26; no CSRF<br/>\\n在沒有cookie的地方非常好使用(如native app)，並且不使用cookie，不會有CSRF的問題發生。</p>\\n</li>\\n<li>\\n<p>效能up<br/>\\n簡單來說，token裡面可以夾帶user訊息(新式token如JWT)，這樣可以省去查詢DB的時間。另外Session通常記在memory中，對於大型網站的伺服器也是種負擔。</p>\\n</li>\\n</ul>\\n<p>結論:與SPA一樣，現在的Token-based也是一個更主流的開發方式，可以更好的分離程式之間的關聯性，不過前端就要額外做一些事情來處理token囉，結果前端更忙了(無誤)。</p>\\n<p><a href=\\\"http://www.jianshu.com/p/9be79614bcd4\\\">參考網站1</a>   \\n<a href=\\\"https://yami.io/jwt/#\\\">參考網站2</a>   \\n<a href=\\\"https://auth0.com/blog/cookies-vs-tokens-definitive-guide/\\\">參考網站3</a></p>\"}},{\"node\":{\"fields\":{\"slug\":\"/posts/dont-release-zalgo/\"},\"frontmatter\":{\"title\":\"Don't release Zalgo!!\",\"date\":\"2017-08-01T01:30\",\"tags\":[\"promise\",\"javascript\",\"async\"],\"release\":true},\"html\":\"<p><snippet></snippet></p>\\n<p><a href=\\\"https://oren.github.io/blog/zalgo.html\\\">Don't release Zalgo!!!!!</a>\\n同場加映<a href=\\\"http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony\\\">Designing APIs for Asynchrony</a></p>\\n<p>最主要的一句話</p>\\n<blockquote>\\n<p>make sure your function always sync or always async.</p>\\n</blockquote>\\n<p>其實最近看書才知道這個詞，不過以前使用jQuery的時候就有設計過相似的概念。</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">function</span> <span class=\\\"token function\\\">getData</span><span class=\\\"token punctuation\\\">(</span>url<span class=\\\"token punctuation\\\">,</span> model<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">var</span> df <span class=\\\"token operator\\\">=</span> $<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">Deffered</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token keyword\\\">if</span><span class=\\\"token punctuation\\\">(</span>model<span class=\\\"token punctuation\\\">.</span>data<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n      df<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">resolve</span><span class=\\\"token punctuation\\\">(</span>model<span class=\\\"token punctuation\\\">.</span>data<span class=\\\"token punctuation\\\">)</span>\\n    <span class=\\\"token punctuation\\\">}</span> <span class=\\\"token keyword\\\">else</span> <span class=\\\"token keyword\\\">async</span><span class=\\\"token operator\\\">...</span>\\n    <span class=\\\"token keyword\\\">return</span> df<span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n</code></pre>\\n      </div>\\n<p>當時的想法也很簡單，我寫了一個getData function有時候直接可以取得，有時候需要非同步很麻煩，乾脆直接包起來就好了，這樣出去以後可以統一.then()多方便，寫著寫著就成習慣了。</p>\\n<p>最近買了小黃書才知道原來這是個好寫法(寫得好)，當然其中還有很多原因，還包括了promise的一些特性，書裡面推崇的是es6的promise，jQuery版本的可能只有make sure your function always sync or always async這個概念。</p>\\n<p>等有空一點再來介紹。</p>\\n<p>PS.目前專案是與fetch寫在一起，但我總覺得哪裡還需要改進，譬如說不需要resolve(false)，而是由component connect state去判斷是否有成功，對於async await還有try catch的部分還不熟，之後要多爬文囉。</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code><span class=\\\"token comment\\\" spellcheck=\\\"true\\\">// redux with thunk</span>\\n<span class=\\\"token punctuation\\\">(</span>data<span class=\\\"token punctuation\\\">,</span> url<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">=></span> <span class=\\\"token punctuation\\\">(</span>dispatch<span class=\\\"token punctuation\\\">,</span> getState<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">=></span> <span class=\\\"token punctuation\\\">(</span>\\n  <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">Promise</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">(</span>resolve<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">=></span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">if</span><span class=\\\"token punctuation\\\">(</span>data<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n      <span class=\\\"token function\\\">dispatch</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'done'</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n      <span class=\\\"token function\\\">resolve</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token boolean\\\">true</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token punctuation\\\">}</span> <span class=\\\"token keyword\\\">else</span> <span class=\\\"token punctuation\\\">{</span>\\n      <span class=\\\"token function\\\">fetch</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">then</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">=></span> <span class=\\\"token punctuation\\\">{</span>\\n        <span class=\\\"token function\\\">dispatch</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token function\\\">doSomething</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span> <span class=\\\"token comment\\\" spellcheck=\\\"true\\\">//塞資料進入store</span>\\n        <span class=\\\"token function\\\">dispatch</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'done'</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token function\\\">resolve</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token boolean\\\">true</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n      <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token keyword\\\">catch</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">(</span>e<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">=></span> <span class=\\\"token punctuation\\\">{</span>\\n        <span class=\\\"token function\\\">dispatch</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'error'</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token function\\\">resolve</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token boolean\\\">false</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n      <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token punctuation\\\">}</span>\\n  <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span>\\n<span class=\\\"token punctuation\\\">)</span>\\n</code></pre>\\n      </div>\"}},{\"node\":{\"fields\":{\"slug\":\"/posts/fetch-in-react-life-cycle/\"},\"frontmatter\":{\"title\":\"在React life cyle中做async\",\"date\":\"2017-07-30T21:15\",\"tags\":[\"react\",\"javascript\"],\"release\":true},\"html\":\"<snippet>\\n最近需要幫網站加入權限的機制，到底該怎們將權限加入React中\\n</snippet>\\n<p>由於公司是走oauth2.0，oauth2.0的官網在SPA推薦的是implicit flow，在npm也可以找到此部分的套件，但這不是這篇文章的重點，重點在於接完之後，該如何進行下一步驗證。</p>\\n<p>通常SPA要驗證一定會有一個flag或一組key，來做後續的動作，當然server端一定也要驗證，不然我前台亂輸入flag與key，資料就全部被弄出來了，以oauth來說我們就必須將accessToken當作前台的一個驗證。</p>\\n<p>這邊我的作法如下</p>\\n<p>確認是否有token -> request api取得個人資訊 -> 有了才登入 沒有就是假token</p>\\n<p>所以我們可以在首次render SPA的時候(也就是使用者第一次點開你的網頁的時候)進行request api的行為。</p>\\n<p>那到底要放在componentWillMount還是componentDidMount呢</p>\\n<h3>componentWillMount</h3>\\n<p>在Component Render之前就會執行，但是fetch資料屬於非同步，render並不會等待，此時還拿不到init state，有可能會出錯，必須自己在constructor先init state，<a href=\\\"https://daveceddia.com/watch-out-for-undefined-state/\\\">詳情見此</a>，會render多次。</p>\\n<h3>componentDidMount</h3>\\n<p>就跟上面做了個對比，是比較建議放入ajax的地方，也會render多次。</p>\\n<p>不過剛好最近出了v0.16，依照這篇<a href=\\\"https://www.reddit.com/r/reactjs/comments/5fg7iq/why_should_ajax_requests_go_in_componentdidmount/\\\">文章</a>來看，componentWillMount似乎是個好選擇(我還沒有驗證)</p>\\n<p>若是與redux連接，可以在provider的那層(通常是app)，componentWillMount的時候執行store.dispatch(fn)，似乎也蠻符合SPA的開發方式，有一些preload可以放在此處，不過實際上接的時候還是會遇到一些問題，之後再討論囉。</p>\"}},{\"node\":{\"fields\":{\"slug\":\"/posts/react-setstate/\"},\"frontmatter\":{\"title\":\"React的setState非同步行為\",\"date\":\"2017-07-28T20:00\",\"tags\":[\"react\",\"javascript\"],\"release\":true},\"html\":\"<snippet>\\n其實我想很多人都知道React的setState是非同步的行為，但是通常還是會順順地使用它，直到他真的發生了奇妙的事情以後，才會開始認真思考這個問題。\\n</snippet>\\n<p>沒錯，那個認真思考問題的人就是我。在專案裡面的登入頁面中，被埋了sleep 1秒的code，前人告訴我那是為了他debug方便而寫的，當我把這行code拿掉的時候，怎麼登都無法登入，這時候我臉上都冒出三條線了...</p>\\n<p>一定很多人都看過React的官方文件</p>\\n<blockquote>\\n<p>setState() does not immediately mutate this.state but creates a pending state transition. Accessing this.state after calling this method can potentially return the existing value. There is no guarantee of synchronous operation of calls to setState and calls may be batched for performance gains.</p>\\n</blockquote>\\n<p>在react的github上也很多人再討論是否要加入promise的<a href=\\\"https://github.com/facebook/react/issues/2642\\\">功能</a>，因為開發者說明performance issues就不提供了。</p>\\n<p>不過其實setState提供了callback方法。(很顯然大家不喜歡寫callback)</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">setState</span><span class=\\\"token punctuation\\\">(</span>state<span class=\\\"token punctuation\\\">,</span> callback<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n</code></pre>\\n      </div>\\n<p>整理以後可以寫成下方的這種形式，就可以接者await使用</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">class</span> <span class=\\\"token class-name\\\">extends</span> Component <span class=\\\"token punctuation\\\">{</span>\\n    setStateAsync <span class=\\\"token operator\\\">=</span> state <span class=\\\"token operator\\\">=></span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">Promise</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">(</span>resolve<span class=\\\"token punctuation\\\">)</span><span class=\\\"token operator\\\">=></span><span class=\\\"token punctuation\\\">{</span>\\n      <span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">setState</span><span class=\\\"token punctuation\\\">(</span>state<span class=\\\"token punctuation\\\">,</span> resolve<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n\\n<span class=\\\"token punctuation\\\">}</span>\\n</code></pre>\\n      </div>\\n<p>這樣我要來解我的登入BUG了..</p>\"}},{\"node\":{\"fields\":{\"slug\":\"/posts/first-post/\"},\"frontmatter\":{\"title\":\"使用gatsby做自己的blog\",\"date\":\"2017-07-26T22:06\",\"tags\":[\"blog\"],\"release\":true},\"html\":\"<snippet>\\n測試一下\\n</snippet>\\n<p>其實沒什麼要說的</p>\\n<p>晚點再補</p>\"}}]}},\"pathContext\":{\"offset\":12,\"paginations\":6,\"total\":17}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---2-bebcdd9bfa1a63df6f71.js","module.exports = {\"data\":{\"allMarkdownRemark\":{\"edges\":[{\"node\":{\"fields\":{\"slug\":\"/posts/session_n_token/\"},\"frontmatter\":{\"title\":\"SPA, Session vs Token-based認證\",\"date\":\"2017-08-12T19:07\",\"tags\":[\"Session\",\"REST\",\"Authorization\"],\"release\":true},\"html\":\"<p>進入了SPA的世界中，這算是目前前端的趨勢。以前都沒有寫過SPA，SPA的好處在網路上寫了很多，我個人認知的就是更好的UX，使用起來更像native，\\n另外就是很好的前後端分離，讓後端更著重在model的部分。不過介紹SPA不是這篇文章的重點，就不多贅述。</p>\\n<p>原本是想寫Oauth在SPA的一些處理心得，但是爬一爬文章就寫了一下Session與Token-based認證的比較。</p>\\n<p>先介紹State<br/>\\n中文直譯就是狀態，在react裡面也有用到，代表的就是UI的狀態，譬如說isOpenNav...，而這邊所提的是HTTP的狀態，HTTP屬於stateless的協定，\\n簡單分類的話就是伺服器會不會記得你所做的事情，假設你在網站中修改了個人檔案的姓名發送request，然後接著修改個人檔案的大頭貼另外又發送一個request，\\n兩個request之間沒有任何關係，server也不會記得每個request你做了什麼，這樣就屬於一種stateless。</p>\\n<p>Session<br/>\\n具有狀態性(Stateful)，由於Session是你與server的連線紀錄，儲存在server端。</p>\\n<h3>Session儲存的缺點</h3>\\n<ul>\\n<li>\\n<p>scalable較麻煩<br/>\\n試想若是後端有做loadbalance的機制，第一次進入登入頁面被導入server1，登入後Session儲存在server1，結果進入頁面後按了某個功能被導到server2，\\n但此server沒有你的Session就可能重新回到登入頁面，當然有一些其他的解決方案(Redis等...)</p>\\n</li>\\n<li>\\n<p>CORS問題<br/>\\n若是使用Session則通常你的client與server要設在同一個domain或sub domain(因為你可能要在cookie裡面傳送東西，cross domain不好處理)，\\n例如app.example.com的網頁，發送請求給api.example.com的server，但若是使用token-based，則可以很好的解決這個問題(因為user data會隨著http header而非cookie)</p>\\n</li>\\n</ul>\\n<h3>Token-based的好處</h3>\\n<ul>\\n<li>\\n<p>低耦合性 &#x26; Stateless<br/>\\n不需要將你的認證綁住server端，只要有一組token，每個server，每個api都可以使用。並且屬於無狀態性，要做scalable很容易，大家都使用統一的token。</p>\\n</li>\\n<li>\\n<p>Mobile friendly &#x26; no CSRF<br/>\\n在沒有cookie的地方非常好使用(如native app)，並且不使用cookie，不會有CSRF的問題發生。</p>\\n</li>\\n<li>\\n<p>效能up<br/>\\n簡單來說，token裡面可以夾帶user訊息(新式token如JWT)，這樣可以省去查詢DB的時間。另外Session通常記在memory中，對於大型網站的伺服器也是種負擔。</p>\\n</li>\\n</ul>\\n<p>結論:與SPA一樣，現在的Token-based也是一個更主流的開發方式，可以更好的分離程式之間的關聯性，不過前端就要額外做一些事情來處理token囉，結果前端更忙了(無誤)。</p>\\n<p><a href=\\\"http://www.jianshu.com/p/9be79614bcd4\\\">參考網站1</a>   \\n<a href=\\\"https://yami.io/jwt/#\\\">參考網站2</a>   \\n<a href=\\\"https://auth0.com/blog/cookies-vs-tokens-definitive-guide/\\\">參考網站3</a></p>\"}},{\"node\":{\"fields\":{\"slug\":\"/posts/dont-release-zalgo/\"},\"frontmatter\":{\"title\":\"Don't release Zalgo!!\",\"date\":\"2017-08-01T01:30\",\"tags\":[\"promise\",\"javascript\",\"async\"],\"release\":true},\"html\":\"<p><snippet></snippet></p>\\n<p><a href=\\\"https://oren.github.io/blog/zalgo.html\\\">Don't release Zalgo!!!!!</a>\\n同場加映<a href=\\\"http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony\\\">Designing APIs for Asynchrony</a></p>\\n<p>最主要的一句話</p>\\n<blockquote>\\n<p>make sure your function always sync or always async.</p>\\n</blockquote>\\n<p>其實最近看書才知道這個詞，不過以前使用jQuery的時候就有設計過相似的概念。</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">function</span> <span class=\\\"token function\\\">getData</span><span class=\\\"token punctuation\\\">(</span>url<span class=\\\"token punctuation\\\">,</span> model<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">var</span> df <span class=\\\"token operator\\\">=</span> $<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">Deffered</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token keyword\\\">if</span><span class=\\\"token punctuation\\\">(</span>model<span class=\\\"token punctuation\\\">.</span>data<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n      df<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">resolve</span><span class=\\\"token punctuation\\\">(</span>model<span class=\\\"token punctuation\\\">.</span>data<span class=\\\"token punctuation\\\">)</span>\\n    <span class=\\\"token punctuation\\\">}</span> <span class=\\\"token keyword\\\">else</span> <span class=\\\"token keyword\\\">async</span><span class=\\\"token operator\\\">...</span>\\n    <span class=\\\"token keyword\\\">return</span> df<span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n</code></pre>\\n      </div>\\n<p>當時的想法也很簡單，我寫了一個getData function有時候直接可以取得，有時候需要非同步很麻煩，乾脆直接包起來就好了，這樣出去以後可以統一.then()多方便，寫著寫著就成習慣了。</p>\\n<p>最近買了小黃書才知道原來這是個好寫法(寫得好)，當然其中還有很多原因，還包括了promise的一些特性，書裡面推崇的是es6的promise，jQuery版本的可能只有make sure your function always sync or always async這個概念。</p>\\n<p>等有空一點再來介紹。</p>\\n<p>PS.目前專案是與fetch寫在一起，但我總覺得哪裡還需要改進，譬如說不需要resolve(false)，而是由component connect state去判斷是否有成功，對於async await還有try catch的部分還不熟，之後要多爬文囉。</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code><span class=\\\"token comment\\\" spellcheck=\\\"true\\\">// redux with thunk</span>\\n<span class=\\\"token punctuation\\\">(</span>data<span class=\\\"token punctuation\\\">,</span> url<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">=></span> <span class=\\\"token punctuation\\\">(</span>dispatch<span class=\\\"token punctuation\\\">,</span> getState<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">=></span> <span class=\\\"token punctuation\\\">(</span>\\n  <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">Promise</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">(</span>resolve<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">=></span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">if</span><span class=\\\"token punctuation\\\">(</span>data<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n      <span class=\\\"token function\\\">dispatch</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'done'</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n      <span class=\\\"token function\\\">resolve</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token boolean\\\">true</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token punctuation\\\">}</span> <span class=\\\"token keyword\\\">else</span> <span class=\\\"token punctuation\\\">{</span>\\n      <span class=\\\"token function\\\">fetch</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">then</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">=></span> <span class=\\\"token punctuation\\\">{</span>\\n        <span class=\\\"token function\\\">dispatch</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token function\\\">doSomething</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span> <span class=\\\"token comment\\\" spellcheck=\\\"true\\\">//塞資料進入store</span>\\n        <span class=\\\"token function\\\">dispatch</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'done'</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token function\\\">resolve</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token boolean\\\">true</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n      <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token keyword\\\">catch</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">(</span>e<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">=></span> <span class=\\\"token punctuation\\\">{</span>\\n        <span class=\\\"token function\\\">dispatch</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'error'</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token function\\\">resolve</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token boolean\\\">false</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n      <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token punctuation\\\">}</span>\\n  <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span>\\n<span class=\\\"token punctuation\\\">)</span>\\n</code></pre>\\n      </div>\"}},{\"node\":{\"fields\":{\"slug\":\"/posts/fetch-in-react-life-cycle/\"},\"frontmatter\":{\"title\":\"在React life cyle中做async\",\"date\":\"2017-07-30T21:15\",\"tags\":[\"react\",\"javascript\"],\"release\":true},\"html\":\"<snippet>\\n最近需要幫網站加入權限的機制，到底該怎們將權限加入React中\\n</snippet>\\n<p>由於公司是走oauth2.0，oauth2.0的官網在SPA推薦的是implicit flow，在npm也可以找到此部分的套件，但這不是這篇文章的重點，重點在於接完之後，該如何進行下一步驗證。</p>\\n<p>通常SPA要驗證一定會有一個flag或一組key，來做後續的動作，當然server端一定也要驗證，不然我前台亂輸入flag與key，資料就全部被弄出來了，以oauth來說我們就必須將accessToken當作前台的一個驗證。</p>\\n<p>這邊我的作法如下</p>\\n<p>確認是否有token -> request api取得個人資訊 -> 有了才登入 沒有就是假token</p>\\n<p>所以我們可以在首次render SPA的時候(也就是使用者第一次點開你的網頁的時候)進行request api的行為。</p>\\n<p>那到底要放在componentWillMount還是componentDidMount呢</p>\\n<h3>componentWillMount</h3>\\n<p>在Component Render之前就會執行，但是fetch資料屬於非同步，render並不會等待，此時還拿不到init state，有可能會出錯，必須自己在constructor先init state，<a href=\\\"https://daveceddia.com/watch-out-for-undefined-state/\\\">詳情見此</a>，會render多次。</p>\\n<h3>componentDidMount</h3>\\n<p>就跟上面做了個對比，是比較建議放入ajax的地方，也會render多次。</p>\\n<p>不過剛好最近出了v0.16，依照這篇<a href=\\\"https://www.reddit.com/r/reactjs/comments/5fg7iq/why_should_ajax_requests_go_in_componentdidmount/\\\">文章</a>來看，componentWillMount似乎是個好選擇(我還沒有驗證)</p>\\n<p>若是與redux連接，可以在provider的那層(通常是app)，componentWillMount的時候執行store.dispatch(fn)，似乎也蠻符合SPA的開發方式，有一些preload可以放在此處，不過實際上接的時候還是會遇到一些問題，之後再討論囉。</p>\"}},{\"node\":{\"fields\":{\"slug\":\"/posts/react-setstate/\"},\"frontmatter\":{\"title\":\"React的setState非同步行為\",\"date\":\"2017-07-28T20:00\",\"tags\":[\"react\",\"javascript\"],\"release\":true},\"html\":\"<snippet>\\n其實我想很多人都知道React的setState是非同步的行為，但是通常還是會順順地使用它，直到他真的發生了奇妙的事情以後，才會開始認真思考這個問題。\\n</snippet>\\n<p>沒錯，那個認真思考問題的人就是我。在專案裡面的登入頁面中，被埋了sleep 1秒的code，前人告訴我那是為了他debug方便而寫的，當我把這行code拿掉的時候，怎麼登都無法登入，這時候我臉上都冒出三條線了...</p>\\n<p>一定很多人都看過React的官方文件</p>\\n<blockquote>\\n<p>setState() does not immediately mutate this.state but creates a pending state transition. Accessing this.state after calling this method can potentially return the existing value. There is no guarantee of synchronous operation of calls to setState and calls may be batched for performance gains.</p>\\n</blockquote>\\n<p>在react的github上也很多人再討論是否要加入promise的<a href=\\\"https://github.com/facebook/react/issues/2642\\\">功能</a>，因為開發者說明performance issues就不提供了。</p>\\n<p>不過其實setState提供了callback方法。(很顯然大家不喜歡寫callback)</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">setState</span><span class=\\\"token punctuation\\\">(</span>state<span class=\\\"token punctuation\\\">,</span> callback<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n</code></pre>\\n      </div>\\n<p>整理以後可以寫成下方的這種形式，就可以接者await使用</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">class</span> <span class=\\\"token class-name\\\">extends</span> Component <span class=\\\"token punctuation\\\">{</span>\\n    setStateAsync <span class=\\\"token operator\\\">=</span> state <span class=\\\"token operator\\\">=></span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">Promise</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">(</span>resolve<span class=\\\"token punctuation\\\">)</span><span class=\\\"token operator\\\">=></span><span class=\\\"token punctuation\\\">{</span>\\n      <span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">setState</span><span class=\\\"token punctuation\\\">(</span>state<span class=\\\"token punctuation\\\">,</span> resolve<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n\\n<span class=\\\"token punctuation\\\">}</span>\\n</code></pre>\\n      </div>\\n<p>這樣我要來解我的登入BUG了..</p>\"}},{\"node\":{\"fields\":{\"slug\":\"/posts/first-post/\"},\"frontmatter\":{\"title\":\"使用gatsby做自己的blog\",\"date\":\"2017-07-26T22:06\",\"tags\":[\"blog\"],\"release\":true},\"html\":\"<snippet>\\n測試一下\\n</snippet>\\n<p>其實沒什麼要說的</p>\\n<p>晚點再補</p>\"}}]}},\"pathContext\":{\"offset\":12,\"paginations\":6,\"total\":17}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/2.json\n// module id = ./node_modules/json-loader/index.js!./.cache/json/2.json\n// module chunks = 157285553617042"],"sourceRoot":""}
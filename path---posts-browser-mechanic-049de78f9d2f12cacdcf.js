webpackJsonp([0xa5f622a06c0b],{460:function(e,a){e.exports={data:{site:{siteMetadata:{title:"前端小誌",author:"Ernie Yang"}},markdownRemark:{id:"/Users/ernieyang09/Desktop/workspace/gatsby-blog/src/pages/posts/2018/03/0325--browser-mechanic.md absPath of file >>> MarkdownRemark",html:'<snippet>\n  原本要介紹javascript event loop的，寫一寫變成介紹browserXDD\n</snippet>\n<p>有人問在處理器\bloading js會block render是為什麼，我知道js是single thread，但並不能確定是single thread的問題，於是乎一切要從browser講起。</p>\n<p>modern browser通常是multi process的，自己認為最大的優點是</p>\n<ul>\n<li>避免一頁crash而導致整個browser crash</li>\n<li>避免插件crash而導致整個browser crash</li>\n</ul>\n<p>而對於前端最重要的就是渲染進程(process)，而一個process又可以分成multi thread，而渲染進程裡面擁有的重要thread</p>\n<ul>\n<li>GUI</li>\n<li>JS</li>\n<li>Event</li>\n<li>Timer</li>\n<li>Http request</li>\n</ul>\n<p>GUI與JS \bthread是戶斥的，因為當repaint的時候會觸發GUI \bthread，但JS執行後很有可能會造成多次repaint，於是乎JS在執行的時候會先block GUI thread，待JS結束後才換GUI thread。</p>\n<p>所以如果在browser裡需要做密集運算可以使用web worker，browser會開一個子thread用來處理運算，但是不能操作dom，這是一個很酷的功能，目前的專案有地方可以優化的，只是browser的支援度還不夠所以放棄(IE 11 up...)，希望未來有機會玩囉。</p>\n<p>假設我們發送了一個http request，browser的行為大致如下</p>\n<ol>\n<li>Get content from http request</li>\n<li>Parse html and create dom tree (trigger DOMContentLoaded)</li>\n<li>Parse css and create render tree(with dom tree)</li>\n<li>(Layout/Reflow) the render tree</li>\n<li>Paint the render tree</li>\n<li>Composite &#x26; show on screen (trigger load)</li>\n</ol>\n<p>\n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 590px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 48.701298701298704%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABYlAAAWJQFJUiTwAAAB6UlEQVQoz11SXW+bMBTNz9/jtP2Bve1h+wd7qKpulaZoSqONkLZAIBAgJkAwBgM2nF3cJWp3pKvra1+f+7kAoSgqdLKZj+gahor9wjj2xh5HbXR1Lskvp9OEKyZt7GkajcxYiOIPTukG7QDMzyf2DG/1Hn0nrv8GevCCBJ4foeqAutiijO8M9fiaf5qwODx9Rex8Qcs9SBEhi27BCweKArZSgLOflD2HkCPqVlPwNfncIWcWWHiDlioqku9Qjf+SYcsDiCqA49pIEhcH6wNOeQo/bsCOLoKHd6jPIRJWYReVSPY/wJxPyMsC69U3hHGMrb3Ek/NoKlmYPpHUEjgwActawt3tUNQaspPom9BoP8oQkDgBw2azxHNwxDHvUPABrJCIGYfSVHLfddCKGkhN5ULidJakezI1Rq2Mk1KKhjOaAaUsxy7MkJ+FGYrWA90r4296ODsyxhBT6j1lMqNuFI5ZhZyPZlgsy9F1Pd6CAmn9L9CLGML5ac5Ak8hBwUtDrJ5s+MczCmbTNG+IrDX94ac1RHb/ZnP+x2JmvWAmtIJH2CROzLEPfiPa3WKf5JAKyLzPSO2PKBsJN/bhJgH9Ga4rYzK8HF4TzxBNj5IaXtPepaykjxM67kCWGzAu8OBZ2EYBOqrsQjjjL3B7+wLRL+N4AAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"\n        alt="RenderTree"\n        title=""\n        src="/static/RenderTree-7efd7b826a452eb48175a6d2846a6b1f-a408b.png"\n        srcset="/static/RenderTree-7efd7b826a452eb48175a6d2846a6b1f-4eabf.png 148w,\n/static/RenderTree-7efd7b826a452eb48175a6d2846a6b1f-5a375.png 295w,\n/static/RenderTree-7efd7b826a452eb48175a6d2846a6b1f-a408b.png 590w,\n/static/RenderTree-7efd7b826a452eb48175a6d2846a6b1f-9a0cc.png 885w,\n/static/RenderTree-7efd7b826a452eb48175a6d2846a6b1f-aa987.png 1180w,\n/static/RenderTree-7efd7b826a452eb48175a6d2846a6b1f-c00d7.png 1540w"\n        sizes="(max-width: 590px) 100vw, 590px"\n      />\n    </span>\n  </span>\n  </p>\n<p>原本我知道javascript要放在body之後或是寫上defer，這邊我才發現css也會block render(dom tree ok，但render tree不行)，但是為了first time render，所以css一定要放在head，但如果很大要進行特殊處理，這邊有另一個領域叫critical render path(因為main css屬於critical但\bjs不是，所以js可以慢load)。</p>\n<p>(這就非常有趣了，首先我不知道webpack包裝成的SPA是怎麼處理css的，另外就是css in jsx，loader，styled-Component各會造成怎樣的效果。之後研究的目標之一)</p>\n<p>composite是另一個很有趣的概念，首先要先了解render pipeline</p>\n<p>\n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 590px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 10.91160220994475%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAYAAABYBvyLAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAm0lEQVQI1yXMTwvBYADAYV/SyUXtMAelltZIS2YbRpJ8ArZx22VZmLO/RydHpU2U9xP8LDs9t6cgzmXEWUJcK4iLxPckEczueMM3npOwGqe4gwTfeeFPHliRjhmrGNs69r7519yp2HGD1rpKQRxLeXSR8/hQJJjecJ0Pi16SZXm4HKXM+0+6oY4RK+hRjU6WtTcKVqxlYRMtlPkB1Q51jFyu9xUAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"\n        alt="render_pipeline"\n        title=""\n        src="/static/render_pipeline-18578f2ae7d686d16ac1ea1bc606f83c-a408b.png"\n        srcset="/static/render_pipeline-18578f2ae7d686d16ac1ea1bc606f83c-4eabf.png 148w,\n/static/render_pipeline-18578f2ae7d686d16ac1ea1bc606f83c-5a375.png 295w,\n/static/render_pipeline-18578f2ae7d686d16ac1ea1bc606f83c-a408b.png 590w,\n/static/render_pipeline-18578f2ae7d686d16ac1ea1bc606f83c-9a0cc.png 885w,\n/static/render_pipeline-18578f2ae7d686d16ac1ea1bc606f83c-aa987.png 1180w,\n/static/render_pipeline-18578f2ae7d686d16ac1ea1bc606f83c-52bff.png 1448w"\n        sizes="(max-width: 590px) 100vw, 590px"\n      />\n    </span>\n  </span>\n  </p>\n<p>在前端的渲染機制是這樣</p>\n<ul>\n<li>Javascript - trigger event</li>\n<li>Style - css selector</li>\n<li>Layout - calculate Layout</li>\n<li>Paint - fill pixel</li>\n<li>Composite - layer merge</li>\n</ul>\n<p>只介紹後面三個，跟頁面排版有關的東西會重新計算(width, height, left...)，此種行為觸發layout，跟繪制有關的觸發paint(color, border...)，跟layer有關的觸發composite，這是一個pipeline，但不是每一個都要經過，經過越少step的效能越好。而通常在一個沒有特別設置的頁面只會有一個layer(或是browser預設的layer?待求證)，但我們可以用tranform, translate 3d, will-change等去特別制造一個layer出來，最後composite的時候就會組合起來。所以就以純移動來講，使用tranform(\bStyle -> Composite)比left(\bStyle -> Layout -> Paint -> Composite)好，但實際使用一個頁面太多layer反而會降低效率，所以這又很吃應用場景。</p>\n<p>當你修改了某些css的style，會產生不同的cost。這邊有份<a href="https://www.slideshare.net/ApoorvSaxena/performance-beyond-page-load">簡報</a>，甚至你可以到<a href="https://csstriggers.com/">css trigger</a>查詢。</p>\n<p>(這邊也非常有趣，沒有實際優化過，不過用過一兩次will-change)</p>\n<p>PS. 其實大部份的概念來自<a href="http://www.dailichun.com/2018/01/21/js_singlethread_eventloop.html">這篇文章</a>，建議好好的看過文章，因為我的版本省略了很多介紹XD</p>\n<p>不過以上介紹的東西在現代的前端開發(SPA component...)還需要再釐清，很多都是3-4年前的推廣，像是css建議多用class而不要js控制，但jsx推崇css in js，另外在render部份使用vdom技術，加上使用webpack打包會不會已經不用關注某些問題值得再討論。</p>',fields:{slug:"/posts/browser-mechanic/"},frontmatter:{title:"Browser render & performance",date:"2018-03-25T15:29",tags:["mechanic","performance tuning"]}}},pathContext:{slug:"/posts/browser-mechanic/"}}}});
//# sourceMappingURL=path---posts-browser-mechanic-049de78f9d2f12cacdcf.js.map
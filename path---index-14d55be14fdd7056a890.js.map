{"version":3,"sources":["webpack:///path---index-14d55be14fdd7056a890.js","webpack:///./.cache/json/index.json"],"names":["webpackJsonp","450","module","exports","data","allMarkdownRemark","edges","node","fields","slug","frontmatter","title","date","tags","release","html","pathContext","offset","paginations","total"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,mBAAqBC,QAAUC,MAAQC,QAAUC,KAAA,oCAA0CC,aAAgBC,MAAA,8CAAAC,KAAA,mBAAAC,MAAA,WAAAC,SAAA,GAAkHC,KAAA,87NAA4nOR,MAAQC,QAAUC,KAAA,6BAAmCC,aAAgBC,MAAA,4BAAAC,KAAA,mBAAAC,MAAA,YAAAC,SAAA,GAAiGC,KAAA,6qRAAm5RR,MAAQC,QAAUC,KAAA,6BAAmCC,aAAgBC,MAAA,2BAAAC,KAAA,mBAAAC,MAAA,YAAAC,SAAA,GAAgGC,KAAA;IAAwnyBR,MAAQC,QAAUC,KAAA,8BAAoCC,aAAgBC,MAAA,yCAAAC,KAAA,mBAAAC,MAAA,YAAAC,SAAA,GAA8GC,KAAA,g/SAA+wTR,MAAQC,QAAUC,KAAA,4BAAkCC,aAAgBC,MAAA,+BAAAC,KAAA,mBAAAC,MAAA,iCAAAC,SAAA,GAAyHC,KAAA,+oMAAqsMR,MAAQC,QAAUC,KAAA,yBAA+BC,aAAgBC,MAAA,gBAAAC,KAAA,mBAAAC,MAAA,mBAAAC,SAAA,GAA4FC,KAAA,grCAAyrCC,aAAgBC,OAAA,EAAAC,YAAA,EAAAC,MAAA","file":"path---index-14d55be14fdd7056a890.js","sourcesContent":["webpackJsonp([142629428675168],{\n\n/***/ 450:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"allMarkdownRemark\":{\"edges\":[{\"node\":{\"fields\":{\"slug\":\"/posts/webpack-manifest-n-chunk/\"},\"frontmatter\":{\"title\":\"webpack production part 下(chunk & manifest)\",\"date\":\"2018-10-14T16:56\",\"tags\":[\"webpack\"],\"release\":true},\"html\":\"<snippet>\\n  此篇為雜記，我想到啥就記啥。主要的話會跟js caching有關\\n  此篇webpack為4.x version\\n</snippet>\\n<p>在前端領域中，bundle是很重要的，dev build跟production build大小，我舉例手上的專案，9mb -> 3xx kb(gzip)。</p>\\n<p>關於檔案大小的部份不在此介紹中。這應該是比較簡單的part，只要你mode有開prodction應該就差很多了。\\n(好吧 我想寫caching 上集晚點補)</p>\\n<p>靜態檔案cache是一個很重要的機制，cache的好，使用者不用每次進網頁都載一次檔案。這點在前端蠻容易被忽略的(至少對於我本人)。在本地端開發的時候很少會感受到file size的影響，上了production習慣開dev tool + disable cached。</p>\\n<p>cache通常會提到server設定，不過我們這邊要提的如何讓webpack做long term cache</p>\\n<p>首先要知道的就是一般使用webpack output file會長這樣</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code class=\\\"language-js\\\">output<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token punctuation\\\">{</span>\\n  filename<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token string\\\">'[name].[chunkhash].js'</span><span class=\\\"token punctuation\\\">,</span>\\n  path<span class=\\\"token punctuation\\\">:</span> path<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">resolve</span><span class=\\\"token punctuation\\\">(</span>__dirname<span class=\\\"token punctuation\\\">,</span> <span class=\\\"token string\\\">'../dist'</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">,</span>\\n<span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">,</span></code></pre>\\n      </div>\\n<br/>\\n<p><strong>為什麼要加hash</strong></p>\\n<p>基於正常使用者不會每次進入頁面都clean cached，若是今天線上版的foo.js要更新</p>\\n<p>client端看到foo.js名稱一樣使用舊的cache，後果不堪設想。(頁面極度容易掛掉)</p>\\n<p>所以每次build的時候依據檔案的內容產生不一樣的的md5加在後面，client端看到不一樣的檔案名稱就會抓取新的檔案</p>\\n<p>為啥不用 static.file?v=xx.xx.xx 可以看參考</p>\\n<p>好解法=使用hash file name 先佈static file再佈頁面</p>\\n<p>這是如果有使用cdn之類的功能的話，如果是docker一起丟file+html是沒差的</p>\\n<p>請視狀況而定</p>\\n<p>long term caching講的是如何在每次佈版的時候，只針對最少的js改動(其他保留不變)</p>\\n<br />\\n<h3>hash &#x26;&#x26; chunkhash</h3>\\n<p>了解這兩個的差異是開始的第一步</p>\\n<p>不過自行了解一下code splitting(我好像沒介紹)</p>\\n<p>對於hash，計算所有chunks的hash，也就是所有檔案後面接的hash會一樣</p>\\n<p>對於chunkhash，每個chunk單獨計算hash</p>\\n<blockquote>\\n<p>不用在dev放上hash，會增加build的時間</p>\\n</blockquote>\\n<p>我們希望當只有一個檔案更新的時候使用者只需要抓一個檔案，想當然要用chunkhash</p>\\n<p>至於有使用ExtractTextPlugin的人可以google一下content-hash</p>\\n<p>因為我們在新的專案使用styled components所以沒有這個問題</p>\\n<p><br/><br/></p>\\n<p>這麼簡單的結束了嗎(X)</p>\\n<p>實際在做旳時候，就算是某檔案完全沒更動也是換了hash value。</p>\\n<p>上網查了後，我們還需要了解manifest與runtime</p>\\n<h4>runtime</h4>\\n<p>webpack在連接所有的code與module相依時(js load完了沒，這module需要啥其他module)，會需要一段code來做這些事情，而這段code就稱之runtime</p>\\n<h4>manifest</h4>\\n<p>當你寫著import, require，compile之後會變成webpack的module，在code裡面常常看到樣的code</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code class=\\\"language-js\\\"><span class=\\\"token function\\\">__webpack_require__</span><span class=\\\"token punctuation\\\">(</span>id<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token comment\\\">// &lt;&lt;&lt; id</span></code></pre>\\n      </div>\\n<p>而什麼module對應什麼id這些就是manifest做的</p>\\n<p>當你新增或刪除module, module排列的id會變動，這些東西寫在chunk裡面每次就需要rebuild。</p>\\n<p>在webpack4中，可以設置runChunk: true，會將runtime與manifest拉出來(each entry has a runtime)</p>\\n<p>這樣可以確保剩下的code之中不會挾雜其他\\b的module id</p>\\n<blockquote>\\n<p>webpack 4.x 沒有 CommonsChunkPlugin</p>\\n</blockquote>\\n<br />\\n<p>另外對於manifest，拉出來還不夠看。</p>\\n<p>webpack預設module是name by id(integer)</p>\\n<p>假設現在有 1 , 2 , 3, ,4 ,5 module</p>\\n<p>插入了新的module被歸類在3</p>\\n<p>1不變, 2不變, 3 new, 4 -> original 3, 5 -> original 4, 6, -> original 5</p>\\n<p>這樣子就rebuild了original 3, 4, 5</p>\\n<p>所以我們還會引入NamedModulesPlugin, HashedModuleIdsPlugin</p>\\n<p>一樣是用內容轉成hash，就算上述的事情發生，只需要build new or modified module and rebuild runtimeChunk使用者也不用重新loading file</p>\\n<br/>\\n<p>最後的配置(簡單的)</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code class=\\\"language-js\\\">output<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token punctuation\\\">{</span>\\n  filename<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token string\\\">'[name].[chunkhash].js'</span><span class=\\\"token punctuation\\\">,</span>\\n  path<span class=\\\"token punctuation\\\">:</span> path<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">resolve</span><span class=\\\"token punctuation\\\">(</span>__dirname<span class=\\\"token punctuation\\\">,</span> <span class=\\\"token string\\\">'../dist'</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">,</span>\\n<span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">,</span>\\noptimization<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token punctuation\\\">{</span>\\n  runtimeChunk<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token boolean\\\">true</span><span class=\\\"token punctuation\\\">,</span>  <span class=\\\"token comment\\\">// this line</span>\\n  splitChunks<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token punctuation\\\">{</span>\\n    chunks<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token string\\\">'async'</span><span class=\\\"token punctuation\\\">,</span>\\n    name<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token boolean\\\">true</span><span class=\\\"token punctuation\\\">,</span>\\n    cacheGroups<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token punctuation\\\">{</span> <span class=\\\"token comment\\\">// can do more if you have complex SPA</span>\\n      vendors<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token punctuation\\\">{</span>\\n        test<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token regex\\\">/[\\\\\\\\/]node_modules[\\\\\\\\/]/</span><span class=\\\"token punctuation\\\">,</span>\\n        name<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token string\\\">'vendors'</span><span class=\\\"token punctuation\\\">,</span>\\n        chunks<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token string\\\">'all'</span>\\n      <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">,</span>\\n      components<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token punctuation\\\">{</span>\\n        test<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token regex\\\">/[\\\\\\\\/]components[\\\\\\\\/]/</span><span class=\\\"token punctuation\\\">,</span>\\n        name<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token string\\\">'components'</span><span class=\\\"token punctuation\\\">,</span>\\n        chunks<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token string\\\">'all'</span>\\n      <span class=\\\"token punctuation\\\">}</span>\\n    <span class=\\\"token punctuation\\\">}</span>\\n  <span class=\\\"token punctuation\\\">}</span>\\n<span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">,</span>\\nplugins<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token punctuation\\\">[</span>\\n  <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">webpack<span class=\\\"token punctuation\\\">.</span>HashedModuleIdsPlugin</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">,</span> <span class=\\\"token comment\\\">// this line</span>\\n<span class=\\\"token punctuation\\\">]</span><span class=\\\"token punctuation\\\">,</span></code></pre>\\n      </div>\\n<p>想知道更深的進去參考挖吧</p>\\n<p><a href=\\\"https://www.zhihu.com/question/20790576/answer/32602154\\\">參考1 非常有用</a></p>\\n<p><a href=\\\"https://github.com/pigcan/blog/issues/9\\\">參考2 非常有用</a></p>\"}},{\"node\":{\"fields\":{\"slug\":\"/posts/script-after-body/\"},\"frontmatter\":{\"title\":\"JS CSS in body( position)\",\"date\":\"2018-09-02T17:45\",\"tags\":[\"mechanic\"],\"release\":true},\"html\":\"<snippet>\\n  天啊，原本預計一個月一篇文章，由於本人跑去當了full stack，變得太忙了，周末只想好好休息耍廢。最近新專案終於要上了，處理的也差不多了。只剩一些小bug與performance需要調整我會想辨法，我會努力把文章補回。未來再來看看要不要加一些後端文章(那就不是前端小誌了XD)\\n</snippet>\\n<p>這篇先來個簡單的東西吧，就是script tag, link到底要放在html的哪裡呢</p>\\n<p>直接先講結論</p>\\n<blockquote>\\n<p>放在body之後絕對沒毛病</p>\\n</blockquote>\\n<p>從最簡單講起，大多數人一定知道loading js會block browser的render機制</p>\\n<p>很多<a href=\\\"/posts/browser-mechanic/\\\">之前</a>的概念要知道</p>\\n<blockquote>\\n<p>GUI與JS \\bthread是戶斥的，因為當repaint的時候會觸發GUI \\bthread，但JS執行後很有可能會造成多次repaint，於是乎JS在執行的時候會先block GUI thread，待JS結束後才換GUI thread。</p>\\n</blockquote>\\n<p>於似乎我們可以用async defer這兩個關鍵字去處理，這蠻簡單的，直接看圖吧</p>\\n<p>\\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block; ; max-width: 590px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 55.00921942224954%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAEF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAB3bQB/8QAFBABAAAAAAAAAAAAAAAAAAAAIP/aAAgBAQABBQJf/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFBABAAAAAAAAAAAAAAAAAAAAIP/aAAgBAQAGPwJf/8QAGRAAAwADAAAAAAAAAAAAAAAAABARAZHw/9oACAEBAAE/IcdDahF//9oADAMBAAIAAwAAABBDz//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EAB0QAAIBBAMAAAAAAAAAAAAAAAABESExUYFxkdH/2gAIAQEAAT8Qa6VOUsU47C3shHjEmBKD/9k='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"js_async_n_defer\\\"\\n        title=\\\"\\\"\\n        src=\\\"/static/js_async_n_defer-8fb190e9baa4e48eb996dd90c239547b-ca545.jpg\\\"\\n        srcset=\\\"/static/js_async_n_defer-8fb190e9baa4e48eb996dd90c239547b-aa1b7.jpg 148w,\\n/static/js_async_n_defer-8fb190e9baa4e48eb996dd90c239547b-b937a.jpg 295w,\\n/static/js_async_n_defer-8fb190e9baa4e48eb996dd90c239547b-ca545.jpg 590w,\\n/static/js_async_n_defer-8fb190e9baa4e48eb996dd90c239547b-75639.jpg 885w,\\n/static/js_async_n_defer-8fb190e9baa4e48eb996dd90c239547b-8bd51.jpg 1180w,\\n/static/js_async_n_defer-8fb190e9baa4e48eb996dd90c239547b-868d3.jpg 1627w\\\"\\n        sizes=\\\"(max-width: 590px) 100vw, 590px\\\"\\n      />\\n    </span>\\n  </span>\\n  </p>\\n<p>如果使用了defer，放在header跟body後就根本沒差別了，其他的case放在body後是個保險的寫法</p>\\n<p>但有一個很重要的點</p>\\n<p><font color='red'><strong>defer不保証執行順序 defer不保証執行順序 defer不保証執行順序(由上到下)</strong></font></p>\\n<p>實際上碰到的，專案裡有一個external file是公司寫好的logger module(es5 CMD)，並不是build在webpack的entry裡。</p>\\n<p>原本是兩個檔案 A &#x26; B</p>\\n<p>因為defer不保証順序，所以我這樣寫</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-html\\\"><code class=\\\"language-html\\\"><span class=\\\"token tag\\\"><span class=\\\"token tag\\\"><span class=\\\"token punctuation\\\">&lt;</span>header</span><span class=\\\"token punctuation\\\">></span></span>\\n  <span class=\\\"token tag\\\"><span class=\\\"token tag\\\"><span class=\\\"token punctuation\\\">&lt;</span>script</span> <span class=\\\"token attr-name\\\">async</span> <span class=\\\"token attr-name\\\">src</span><span class=\\\"token attr-value\\\"><span class=\\\"token punctuation\\\">=</span><span class=\\\"token punctuation\\\">'</span>a.js<span class=\\\"token punctuation\\\">'</span></span><span class=\\\"token punctuation\\\">></span></span><span class=\\\"token script language-javascript\\\"></span><span class=\\\"token tag\\\"><span class=\\\"token tag\\\"><span class=\\\"token punctuation\\\">&lt;/</span>script</span><span class=\\\"token punctuation\\\">></span></span>\\n<span class=\\\"token tag\\\"><span class=\\\"token tag\\\"><span class=\\\"token punctuation\\\">&lt;/</span>header</span><span class=\\\"token punctuation\\\">></span></span>\\n<span class=\\\"token tag\\\"><span class=\\\"token tag\\\"><span class=\\\"token punctuation\\\">&lt;</span>body</span><span class=\\\"token punctuation\\\">></span></span>\\n<span class=\\\"token tag\\\"><span class=\\\"token tag\\\"><span class=\\\"token punctuation\\\">&lt;/</span>body</span><span class=\\\"token punctuation\\\">></span></span>\\n  <span class=\\\"token tag\\\"><span class=\\\"token tag\\\"><span class=\\\"token punctuation\\\">&lt;</span>script</span> <span class=\\\"token attr-name\\\">defer</span> <span class=\\\"token attr-name\\\">src</span><span class=\\\"token attr-value\\\"><span class=\\\"token punctuation\\\">=</span><span class=\\\"token punctuation\\\">'</span>b.js<span class=\\\"token punctuation\\\">'</span></span><span class=\\\"token punctuation\\\">></span></span><span class=\\\"token script language-javascript\\\"></span><span class=\\\"token tag\\\"><span class=\\\"token tag\\\"><span class=\\\"token punctuation\\\">&lt;/</span>script</span><span class=\\\"token punctuation\\\">></span></span></code></pre>\\n      </div>\\n<p>async load完就執行，defer要等到DOMContentLoaded之前執行</p>\\n<p>覺得OK(X) 好像失敗了(O)</p>\\n<p>在正常開發人員always clean cache every refresh下完全ok</p>\\n<p>但是在browser有cache的情況下，不保証執行順序就炸了(都是0秒 loading time)</p>\\n<p>最後的解法是將兩個檔案放在一起(在最後的版本我開了一個webpack entry還是bundle了)</p>\\n<p><br/><br/></p>\\n<p>寫到這裡，先轉個話題談談css</p>\\n<p>為什麼css必須放在header呢</p>\\n<p>原因是css屬於關鍵渲染路徑(critical render path)中的一環</p>\\n<p>過慢的loading會delay domContentLoaded的時間，而因為網頁的評分中將未加載css的網頁視為沒載完(因為很醜無法閱讀)，沒辨法跟js一樣async loading</p>\\n<p>這篇<a href=\\\"https://www.cnblogs.com/libin-1/p/7127330.html\\\">文章</a>說的很好，配上上面的之前文章，直接拿結論</p>\\n<ol>\\n<li>css 不會影響dom tree parsing</li>\\n<li>css 會影響 dom tree rendering(因為css dom tree還沒建好)</li>\\n<li>css 與js互斥，原因上面講了</li>\\n</ol>\\n<p>隨便提一個 do not use @import(我用google font的時候被偵測到)，原因是又delay loading</p>\\n<p>(之後開個文章把所有有用的tunning都寫進去)</p>\\n<p>又回到js部份，這也是真的該理解的部份</p>\\n<p>既然js會block render，那反正js放header跟放body後不都一樣</p>\\n<p>這說法是對的也是錯的。</p>\\n<p>如果所謂的block render指的是complete anything and can intereact with users 那答案是yes，根本就沒差</p>\\n<p>tricky的地方其實是我們關心的是first time render view，而dom tree會在一個網頁被開啟時被重覆更新好幾次(only by js, css必定先讀完)</p>\\n<p>我在網頁文章中的理解是css dom tree的parse決定第一次paint的時間(css 不會影響dom tree parsing，會影響 dom tree rendering)結束parse才觸發js執行，而parse js的行為是會先將js前面的已經ok的dom先paint過一次</p>\\n<ol>\\n<li>css loading time > js loading time 畫面白掉無法paint</li>\\n<li>css loading time &#x3C; js loading time paint到js的那行之前</li>\\n</ol>\\n<p>所以假設</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-html\\\"><code class=\\\"language-html\\\"><span class=\\\"token tag\\\"><span class=\\\"token tag\\\"><span class=\\\"token punctuation\\\">&lt;</span>html</span><span class=\\\"token punctuation\\\">></span></span>\\n  <span class=\\\"token tag\\\"><span class=\\\"token tag\\\"><span class=\\\"token punctuation\\\">&lt;</span>nav</span><span class=\\\"token punctuation\\\">></span></span><span class=\\\"token tag\\\"><span class=\\\"token tag\\\"><span class=\\\"token punctuation\\\">&lt;/</span>nav</span><span class=\\\"token punctuation\\\">></span></span>\\n  <span class=\\\"token tag\\\"><span class=\\\"token tag\\\"><span class=\\\"token punctuation\\\">&lt;</span>script</span> <span class=\\\"token punctuation\\\">></span></span><span class=\\\"token script language-javascript\\\"> heavy js</span><span class=\\\"token tag\\\"><span class=\\\"token tag\\\"><span class=\\\"token punctuation\\\">&lt;/</span>script</span><span class=\\\"token punctuation\\\">></span></span>\\n\\n\\n  <span class=\\\"token tag\\\"><span class=\\\"token tag\\\"><span class=\\\"token punctuation\\\">&lt;</span>body</span><span class=\\\"token punctuation\\\">></span></span>\\n    <span class=\\\"token tag\\\"><span class=\\\"token tag\\\"><span class=\\\"token punctuation\\\">&lt;</span>h1</span><span class=\\\"token punctuation\\\">></span></span><span class=\\\"token tag\\\"><span class=\\\"token tag\\\"><span class=\\\"token punctuation\\\">&lt;/</span>h1</span><span class=\\\"token punctuation\\\">></span></span>\\n    ...\\n    <span class=\\\"token tag\\\"><span class=\\\"token tag\\\"><span class=\\\"token punctuation\\\">&lt;</span>p</span><span class=\\\"token punctuation\\\">></span></span><span class=\\\"token tag\\\"><span class=\\\"token tag\\\"><span class=\\\"token punctuation\\\">&lt;/</span>p</span><span class=\\\"token punctuation\\\">></span></span>\\n  <span class=\\\"token tag\\\"><span class=\\\"token tag\\\"><span class=\\\"token punctuation\\\">&lt;/</span>body</span><span class=\\\"token punctuation\\\">></span></span>\\n<span class=\\\"token tag\\\"><span class=\\\"token tag\\\"><span class=\\\"token punctuation\\\">&lt;/</span>html</span><span class=\\\"token punctuation\\\">></span></span></code></pre>\\n      </div>\\n<p>js執行會阻止下方dom render</p>\\n<p>使用者會在first time render view只看到nav，經過了heavy js execute之後才會繼續向下。</p>\\n<p>那才是為什麼script要放body之後</p>\\n<p>這些東西我以前知道script放body之後，近期才真正弄懂它</p>\\n<br />\\n<p>不過最後思考一個問題，在spa的頁面中，請問script放在body之後有好處嗎</p>\\n<p>我的理解(請反白)</p>\\n<font color='white'>\\n沒啥鳥用，因為你的頁面是heavy js，first time render view = 空白 root element，除非有做ssr那就另當別論\\n</font>\\n<p>這算是老觀念了，我覺得有一些outdated的部份，所以才特別重新review與思考，充份了解還是聊勝於無啊。</p>\\n<p><a href=\\\"https://segmentfault.com/a/1190000004292479\\\">參考1</a></p>\\n<p><a href=\\\"https://segmentfault.com/a/1190000007766425\\\">參考2</a></p>\"}},{\"node\":{\"fields\":{\"slug\":\"/posts/javascript-memory/\"},\"frontmatter\":{\"title\":\"Javascript memory in use\",\"date\":\"2018-04-29T16:18\",\"tags\":[\"mechanic\"],\"release\":true},\"html\":\"<snippet>\\n  整個四月都在忙轉職的事情，而且跑去刷leetcode啦，結果要寫的東西越來越多啦，才發現我連event loop都還沒寫.\\n</snippet>\\n<p>這篇要介紹的是javascript的memory的機制，在認識event loop的時候知道的queue與stack，不過還缺一個heap，還可以順便提一下primitive與object。</p>\\n<p>在js的語言中，只有兩種資料型態</p>\\n<h4>primitive type - 基本型別</h4>\\n<p>\\b\\n包涵以下六種</p>\\n<ul>\\n<li>string</li>\\n<li>number</li>\\n<li>boolean</li>\\n<li>null</li>\\n<li>undefined</li>\\n<li>symbol(es6加入)</li>\\n</ul>\\n<h4>object - 物件 沒啥好說的</h4>\\n<p>在string、number、boolean與symbol有所謂的wrapper object(封裝物件?網路上很多種翻譯)</p>\\n<p>在使用這些primitive的時候，JS會臨時的create一個new [Type] object(ex: new Number(8))，然後進行操作完後就拋棄。請永遠不要用new的方式去初始化參數，原因是啥我忘了，大概在比較上有些不一樣的與速度比一般直接宣告慢。</p>\\n<p>也不要在primitive加properties，以下有一個很簡單的例子</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code class=\\\"language-js\\\"><span class=\\\"token keyword\\\">var</span> s <span class=\\\"token operator\\\">=</span> <span class=\\\"token string\\\">'Hello World'</span><span class=\\\"token punctuation\\\">;</span>\\ns<span class=\\\"token punctuation\\\">.</span>len <span class=\\\"token operator\\\">=</span> <span class=\\\"token string\\\">'len'</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token keyword\\\">var</span> t <span class=\\\"token operator\\\">=</span> s<span class=\\\"token punctuation\\\">.</span>len<span class=\\\"token punctuation\\\">;</span>\\n\\nconsole<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span>t<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token comment\\\">// undefined</span></code></pre>\\n      </div>\\n<p>因為每次操作的時候，都會產生一個新的object，然後就釋放掉，所以t的那行拿不到上一行s.len的值。</p>\\n<p>primitive是call by value的</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code class=\\\"language-js\\\"><span class=\\\"token keyword\\\">var</span> a <span class=\\\"token operator\\\">=</span> <span class=\\\"token number\\\">123</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token keyword\\\">var</span> b <span class=\\\"token operator\\\">=</span> a<span class=\\\"token punctuation\\\">;</span>\\nb <span class=\\\"token operator\\\">=</span> <span class=\\\"token number\\\">456</span><span class=\\\"token punctuation\\\">;</span>\\n\\nconsole<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span>a<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token comment\\\">// 123</span>\\nconsole<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span>b<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token comment\\\">// 456</span></code></pre>\\n      </div>\\n<p>object是call by reference的</p>\\n<p>array是normal object + \\\"special function\\\" 所以也是call by reference</p>\\n<p>然後function也是一種特殊object...(callable object)\\n(要記的清楚好麻煩XD)</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code class=\\\"language-js\\\"><span class=\\\"token keyword\\\">var</span> a <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">{</span>\\n  test<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token boolean\\\">true</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n<span class=\\\"token keyword\\\">var</span> b <span class=\\\"token operator\\\">=</span> a<span class=\\\"token punctuation\\\">;</span>\\n\\nb<span class=\\\"token punctuation\\\">.</span>test <span class=\\\"token operator\\\">=</span> <span class=\\\"token boolean\\\">false</span><span class=\\\"token punctuation\\\">;</span>\\n\\nconsole<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span>a<span class=\\\"token punctuation\\\">.</span>test<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token comment\\\">//false</span>\\nconsole<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span>b<span class=\\\"token punctuation\\\">.</span>test<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token comment\\\">//false</span></code></pre>\\n      </div>\\n<p>PS. 有人說更正確的為call by sharing</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code class=\\\"language-js\\\"><span class=\\\"token keyword\\\">var</span> bar<span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token keyword\\\">var</span> foo <span class=\\\"token operator\\\">=</span> bar<span class=\\\"token punctuation\\\">;</span>\\nbar <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">{</span><span class=\\\"token string\\\">'key'</span> <span class=\\\"token punctuation\\\">:</span> <span class=\\\"token string\\\">'value'</span><span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">;</span>\\nconsole<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span>foo <span class=\\\"token punctuation\\\">,</span> bar <span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n\\n<span class=\\\"token comment\\\">// if call by reference?</span></code></pre>\\n      </div>\\n<p>說的太深又是一篇文章，先略過吧。</p>\\n<br/>\\n<p>那進入我們的memory介紹</p>\\n<p>因為javascript是dynamic language，變數可能隨時改變型別，所以記憶體是動態分配的。</p>\\n<p>不管是primitive或是object皆儲存在heap記憶體中。</p>\\n<p>而stack會保存heap裡面變數的ref</p>\\n<p>\\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block; ; max-width: 590px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 73.875%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAABYlAAAWJQFJUiTwAAABkElEQVQ4y32T2WoDMQxF/f+/ljwmIStZCGQh+767PYJjpqXUIEYjS1fX8nXK3+v9fuf7/Z63222+Xq/x//l8wp7PZ/wbO5/PYa/XK8w9jJUoAIzNTqeTZ7NZ+LfbLT8ejzD2aQTgdDqNPPcul0t8yScvUUyAroPBIC+Xy2BFgqDkEMMHlIVPTJbiJBmMRqOw8Xic5/N5xA6HQzDDF5h/gQA3jgVDNi0CCCPRQuIwZRSwh02VtcA/ACnodrsxG2yxWJQEC4/HYz6dTn8CaXFkj4MBNplMytEEdCywIy6AZJwhftLp9/u53W7nVquVV6tVOZqyEVh5eGFVleAnrxv6HBUtOsNqdxl623y5xGazWWKFoTNBNrDc7XaFocYyV4aOq9okGOLArNFoRMfNZlM6OrfhcBg51Rt2hsaKsBE1YLVaLfd6vWDKJgXsAcgLQZfO8V/ZWITWYIc8eFJIRQas6msRSNAfsmGDm63X6yGd9XodQEqERIX++8gy9vjJ4cNmv9/HhWB2lSGNq09Q37jS+QL8qoxq3PmqzAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"stack_n_heap.png\\\"\\n        title=\\\"\\\"\\n        src=\\\"/static/stack_n_heap-90b51a4be5dbfff29bcca49d861a0e83-a408b.png\\\"\\n        srcset=\\\"/static/stack_n_heap-90b51a4be5dbfff29bcca49d861a0e83-4eabf.png 148w,\\n/static/stack_n_heap-90b51a4be5dbfff29bcca49d861a0e83-5a375.png 295w,\\n/static/stack_n_heap-90b51a4be5dbfff29bcca49d861a0e83-a408b.png 590w,\\n/static/stack_n_heap-90b51a4be5dbfff29bcca49d861a0e83-4cbbd.png 800w\\\"\\n        sizes=\\\"(max-width: 590px) 100vw, 590px\\\"\\n      />\\n    </span>\\n  </span>\\n  </p>\\n<p>primitive跟object的差別在於，primitive會在heap create一個新的，然後將新的ref傳出去，而object不會，只會將現有的ref傳出去。最後，js會自動分辨型別，決定拿到的ref是\\nprimitive還是object。</p>\\n<p>網路上也能找到這張圖</p>\\n<p>\\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block; ; max-width: 436px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 50.68807339449541%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsSAAALEgHS3X78AAABxElEQVQoz11S2XaiUBDk/7/FZ98SGaMzZjREjMriAmpYFBVwQ41ac6tznONJv9wLt6u6urq1PM9RFAW88Qi1eh2j0RjFocB+v8ftdgPj57ndbnE8nTCPQjw9V+D5Po7Hb4xWLpdRe3mBZTtYLBaIogir1UoRj5Bl2X+i6/Uq9+VyCb1SQa1aRb/fRxjFCIMAaZrKt+Y4Dna7HdbrNTabjVSn4tlsJmDG5XKR83A4oFQqYTAYCAEFEMf7+XxGr9eDVv2lw3GHQsYHqqL0yWQigHvwv+u6oEXdbhe2ban3RHL5j0VbrRY0PrIKWyUBVTHBV77M53MhS5JEEdhyZzcDRczcIPhEHMeSR/XNZhPa39dXWFZf+s/zDU7K7MvXlyRSNcnY4j1oSffjQw1xDNuykGZqqIqMPrOoZhiGgKfTKTzPE2WfymS2Z5od8fJxwixC3+M4QhCG0hnx7KrT6UBrNBoCdgcuHFXBsmzlqQvj3RDgnexxZUzTxFhtQZpmal2O4iNjOBx+K6QHVMhKbJEDoNLHtXlUSAvoNdURSz9ZqN1uQ9N1He+K1PcnknxfBe4hyX8Scih/ftfx9mYgUaQkYh5PTvkfILboBpMHtuEAAAAASUVORK5CYII='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"stack_n_heap2.png\\\"\\n        title=\\\"\\\"\\n        src=\\\"/static/stack_n_heap2-e43d40986d2db92e23897b29c69e1700-704f6.png\\\"\\n        srcset=\\\"/static/stack_n_heap2-e43d40986d2db92e23897b29c69e1700-e054b.png 148w,\\n/static/stack_n_heap2-e43d40986d2db92e23897b29c69e1700-1e7c4.png 295w,\\n/static/stack_n_heap2-e43d40986d2db92e23897b29c69e1700-704f6.png 436w\\\"\\n        sizes=\\\"(max-width: 436px) 100vw, 436px\\\"\\n      />\\n    </span>\\n  </span>\\n  </p>\\n<p>primitive是直接存在stack裡面的，也是網路上比較多的文章寫的，我認為就是看環境complier的實作方式。</p>\\n<p>由於這張圖，有人說js只能call by value的，只是傳出去的時候，primitive的value是實際的值，而object的\\bvalue的addr。</p>\\n<p><a href=\\\"https://stackoverflow.com/questions/33125547/javascript-string-stored-on-stack\\\">這篇</a>寫的很好</p>\\n<blockquote>\\n<p>In any case, for the JS programmer, worrying about stacks and heaps is somewhere between meaningless and distracting. It's more important to understand the behavior of various types of values.</p>\\n</blockquote>\\n<p>我認為primitive存在哪裡並不是這麼重要(但primitive與object的比較還有heap memory還是很重要)。然後我個人偏好第一種說法，因為stack的size應為fixed，才有使用stack的優點。</p>\\n<h4>stack &#x26; heap 比較</h4>\\n<table>\\n<thead>\\n<tr>\\n<th>Stack</th>\\n<th>Heap</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>在compile時期知道size</td>\\n<td>在runtime分配size</td>\\n</tr>\\n<tr>\\n<td>FILO(跟function exec順序有關)</td>\\n<td>沒有特別順序</td>\\n</tr>\\n<tr>\\n<td>靜態分配</td>\\n<td>動態分配</td>\\n</tr>\\n</tbody>\\n</table>\\n<h3>memory leak issue</h3>\\n<p>在以前沒有es6與module(common js require)之前，常常用clousre保存變數。那時候是dom的操作，加上瀏覽器引擎沒這麼好，電腦沒這麼強，對於memory要求比較care。現在的話使用eco-system寫好的framework，加上原生的module功能，很少人會特別說到memory的問題，不過對於SPA來說，使用者瀏覽的時間偏長(更正確應該說SPA所有操作都是在同一頁面的javascript)，如果這頁面是面對眾多的user還是需要注意。</p>\\n<p>javascript是動態語言會自己分配memory，同樣的也有自己的GC機制。</p>\\n<p>最簡單的GC演算法，會偵測變數是否有被其他人引用，若是沒有就會進行memory回收。</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code class=\\\"language-js\\\"><span class=\\\"token keyword\\\">var</span> obj1 <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">{</span>\\n  obj2<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token punctuation\\\">{</span><span class=\\\"token punctuation\\\">}</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n<span class=\\\"token comment\\\">// 2 objs create</span>\\n\\n<span class=\\\"token keyword\\\">var</span> obj3 <span class=\\\"token operator\\\">=</span> obj1<span class=\\\"token punctuation\\\">;</span> <span class=\\\"token comment\\\">// obj1 got 2 ref(itself &amp; obj3)</span>\\n\\n<span class=\\\"token keyword\\\">var</span> obj1 <span class=\\\"token operator\\\">=</span> <span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">;</span> <span class=\\\"token comment\\\">// obj1 got 1 ref(obj3)</span>\\n\\n<span class=\\\"token keyword\\\">var</span> obj4 <span class=\\\"token operator\\\">=</span> obj3<span class=\\\"token punctuation\\\">.</span>obj2 <span class=\\\"token comment\\\">// obj2 got 2 ref(obj3's property &amp; obj4)</span>\\n\\nobj3 <span class=\\\"token operator\\\">=</span> <span class=\\\"token number\\\">456</span><span class=\\\"token punctuation\\\">;</span> <span class=\\\"token comment\\\">// no one need obj1, obj1 got GCed</span>\\n\\nobj4 <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">null</span> <span class=\\\"token comment\\\">// no one need obj2, obj2 got GCed</span></code></pre>\\n      </div>\\n<p>但這無法解決cycle ref</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code class=\\\"language-js\\\"><span class=\\\"token keyword\\\">function</span> <span class=\\\"token function\\\">f</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token keyword\\\">var</span> o1 <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">{</span><span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">;</span>\\n  <span class=\\\"token keyword\\\">var</span> o2 <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">{</span><span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">;</span>\\n  o1<span class=\\\"token punctuation\\\">.</span>p <span class=\\\"token operator\\\">=</span> o2<span class=\\\"token punctuation\\\">;</span> <span class=\\\"token comment\\\">// o1 references o2</span>\\n  o2<span class=\\\"token punctuation\\\">.</span>p <span class=\\\"token operator\\\">=</span> o1<span class=\\\"token punctuation\\\">;</span> <span class=\\\"token comment\\\">// o2 references o1. This creates a cycle.</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n\\n<span class=\\\"token function\\\">f</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span></code></pre>\\n      </div>\\n<p>所以後來GC機制改用Mark-and-sweep演算法，簡言之從global當作root，往chilren一步一步走，將走過的變數設為active。最後將非active的變數釋放掉。</p>\\n<p>所以不管有沒有cycle循環，只要root抵達不了就會回收。2012的時候，大部份的modern browser更新了此GC。</p>\\n<p>雖說了這麼多，但還是有四個常見的JS memory leak</p>\\n<h4>global variable</h4>\\n<p>大家都是知道少用global var，且在global = root情況下是不會回收的，比較常見的是</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code class=\\\"language-js\\\"><span class=\\\"token keyword\\\">function</span> <span class=\\\"token function\\\">foo</span><span class=\\\"token punctuation\\\">(</span>arg<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    bar <span class=\\\"token operator\\\">=</span> <span class=\\\"token string\\\">\\\"some text\\\"</span><span class=\\\"token punctuation\\\">;</span> <span class=\\\"token comment\\\">// oops</span>\\n<span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>另外適時的使用global var是好的，不過當不用的時候可以ressign it或是 delete property。</p>\\n<h4>timer &#x26; callback</h4>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code class=\\\"language-js\\\"><span class=\\\"token keyword\\\">var</span> data <span class=\\\"token operator\\\">=</span> <span class=\\\"token string\\\">'123'</span><span class=\\\"token punctuation\\\">;</span>\\n\\n<span class=\\\"token function\\\">setInterval</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">function</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token keyword\\\">var</span> dom <span class=\\\"token operator\\\">=</span> document<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">getElementById</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'test'</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n  test<span class=\\\"token punctuation\\\">.</span>innerHtml <span class=\\\"token operator\\\">=</span> data<span class=\\\"token punctuation\\\">;</span>\\n  <span class=\\\"token comment\\\">// might be better</span>\\n  <span class=\\\"token comment\\\">// document.getElementById('test').innerHtml = data;</span>\\n<span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">,</span><span class=\\\"token number\\\">1000</span><span class=\\\"token punctuation\\\">)</span>\\n\\n<span class=\\\"token comment\\\">// data never GCed</span></code></pre>\\n      </div>\\n<p>由於dom有可能從頁面上消失掉，所以包在function裡面是很多餘的</p>\\n<p>另外data被Interval event使用著，所以never GCed</p>\\n<p>上面的better寫法除了說減少多餘以外，另外因為不用宣告var，memory上略好一點</p>\\n<p>不過code的<a href=\\\"https://stackoverflow.com/questions/8766220/javascript-declaring-variables-or-not\\\">可讀性</a>更重要，我覺得最重要的應該是data不能被GC</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code class=\\\"language-js\\\"><span class=\\\"token keyword\\\">var</span> button<span class=\\\"token operator\\\">=</span> document<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">getElementById</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'button'</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\nbutton<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">addEventListener</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'click'</span><span class=\\\"token punctuation\\\">,</span> onClick<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token comment\\\">//remove yourself if not need</span>\\nbutton<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">removeEventListener</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'click'</span><span class=\\\"token punctuation\\\">,</span> onClick<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span></code></pre>\\n      </div>\\n<p>但聽說現在modern的瀏覽器都會幫忙檢查observer相關的問題了</p>\\n<p>以前都需要自己寫removeListener before remove dom現在就不用囉(但寫了才是有quality的code，而且還是會有非modern browser的使用者)</p>\\n<h4>額外的dom參考</h4>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code class=\\\"language-js\\\"><span class=\\\"token keyword\\\">var</span> elements <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">{</span>\\n    button<span class=\\\"token punctuation\\\">:</span> document<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">getElementById</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'button'</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">,</span>\\n    image<span class=\\\"token punctuation\\\">:</span> document<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">getElementById</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'image'</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">,</span>\\n    text<span class=\\\"token punctuation\\\">:</span> document<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">getElementById</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'text'</span><span class=\\\"token punctuation\\\">)</span>\\n<span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">;</span>\\n\\n<span class=\\\"token keyword\\\">function</span> <span class=\\\"token function\\\">doStuff</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    image<span class=\\\"token punctuation\\\">.</span>src <span class=\\\"token operator\\\">=</span> <span class=\\\"token string\\\">'http://some.url/image'</span><span class=\\\"token punctuation\\\">;</span>\\n    button<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">click</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    console<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span>text<span class=\\\"token punctuation\\\">.</span>innerHTML<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token comment\\\">// Much more logic</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n\\n<span class=\\\"token keyword\\\">function</span> <span class=\\\"token function\\\">removeButton</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token comment\\\">// The button is a direct child of body.</span>\\n    document<span class=\\\"token punctuation\\\">.</span>body<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">removeChild</span><span class=\\\"token punctuation\\\">(</span>document<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">getElementById</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'button'</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n\\n    <span class=\\\"token comment\\\">// At this point, we still have a reference to #button in the global</span>\\n    <span class=\\\"token comment\\\">// elements dictionary. In other words, the button element is still in</span>\\n    <span class=\\\"token comment\\\">// memory and cannot be collected by the GC.</span>\\n<span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>有時候因為方便，會在js裡面寫hash map，對於dom如同有兩個ref(one from dom tree, one from js)。</p>\\n<p>如果你只從dom tree刪除，因為還有js的ref，所以memory無法GC</p>\\n<p>特別的是如果你對一個td做記憶，然後移掉整個table，最後整個table無法被GC(因為必須同時記得他的parent)</p>\\n<p>已經很少對於dom進行直接操作，不過想想以前好像寫過許多這種ng行為XD</p>\\n<h4>Closure</h4>\\n<p>實務上可能每天都在用closure，也有一些很tricky的行為</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code class=\\\"language-js\\\"><span class=\\\"token keyword\\\">var</span> theThing <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">null</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token keyword\\\">var</span> <span class=\\\"token function-variable function\\\">replaceThing</span> <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">function</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token keyword\\\">var</span> originalThing <span class=\\\"token operator\\\">=</span> theThing<span class=\\\"token punctuation\\\">;</span>\\n  <span class=\\\"token keyword\\\">var</span> <span class=\\\"token function-variable function\\\">unused</span> <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">function</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>originalThing<span class=\\\"token punctuation\\\">)</span>\\n      console<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"hi\\\"</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n  <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">;</span>\\n  theThing <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">{</span>\\n    longStr<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">Array</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token number\\\">1000000</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">join</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'*'</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">,</span>\\n    someMethod<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token keyword\\\">function</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n      console<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span>someMessage<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token punctuation\\\">}</span>\\n  <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token function\\\">setInterval</span><span class=\\\"token punctuation\\\">(</span>replaceThing<span class=\\\"token punctuation\\\">,</span> <span class=\\\"token number\\\">1000</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span></code></pre>\\n      </div>\\n<p>網路的文章我看了很久，我不確定我的說法是不是對的</p>\\n<p>因為theThing在replaceThing裡面被引用了，而someMethod是一個closure，其中的一個free variable是unused，但因為unused也是closures，然後同樣parent scope中的closures會互相shared scope。在這個unused裡面又用到了originalThing(引用了上個循環的thingThing)，所以造成這個\\\"上一次\\\"的theThing也需要被記憶不能被GC。</p>\\n<p>我將unused移除，並且用chrome dev tool查看，確實有unused會memory leak，沒有的就不會。</p>\\n<p>其實任何的function在建立時皆為一個closure，並不是function retrun function才是closure。有些定義是需要有free variables才算closure。</p>\\n<p>但由上面的整理也得知，就算closure裡面有許多的var，只要沒有被引用，就不會有memory的問題啦(不過無用的var eslint應該會警告)</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code class=\\\"language-js\\\"><span class=\\\"token comment\\\">// y沒用到會自己被回收，x就會一直保存</span>\\n\\b<span class=\\\"token keyword\\\">const</span> <span class=\\\"token function-variable function\\\">test</span> <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">(</span>x<span class=\\\"token punctuation\\\">,</span>y<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">=></span> z <span class=\\\"token operator\\\">=></span> x <span class=\\\"token operator\\\">+</span> z<span class=\\\"token punctuation\\\">;</span></code></pre>\\n      </div>\\n<p>實際喔，我覺得還是memory detect in action吧 XD，畢竟js這麼神奇。重點是當你從工具中察覺到了memory leak的時候，是否能歸納出是哪種問題。</p>\\n<br>\\n<p>memory可以參考<a href=\\\"https://segmentfault.com/a/1190000007536949\\\">此</a></p>\\n<p>memory leak可以參考<a href=\\\"https://auth0.com/blog/four-types-of-leaks-in-your-javascript-code-and-how-to-get-rid-of-them/\\\">此</a></p>\"}},{\"node\":{\"fields\":{\"slug\":\"/posts/javascript-context/\"},\"frontmatter\":{\"title\":\"Javascript context & execution context\",\"date\":\"2018-03-25T19:49\",\"tags\":[\"mechanic\"],\"release\":true},\"html\":\"<snippet>\\n  這邊試著整理一些javscript的context概念(教練我原本只想寫event loop啊，越寫越多orz...)\\n</snippet>\\n<p>先說說js function，在w3c的\\b<a href=\\\"https://www.w3schools.com/js/js_function_invocation.asp\\\">定義</a>中，呼叫一個function稱為invoke。</p>\\n<p>在看js文章與執行function的時候當會看到一個字 - 執行環境(Execution Context)</p>\\n<p>Execution Context就是執行javascript時候的環境(有講跟沒講一樣XD)，更準確的來說，上下文環境，確認執行時候的this, var, method...</p>\\n<p>Execution Context有三種</p>\\n<ol>\\n<li>Gobal Execution Context - 一開始的地方，browser來說就是window</li>\\n<li>Functional Execution Context - 執行function的地方</li>\\n<li>Eval - 不常用</li>\\n</ol>\\n<p>當js invoke一個function時，會從global開始呼叫function，並且建立execution context，如果有很多function，就會一層疊一層的，此稱為execution context stack，而我們執行function的方式稱之為call stack。</p>\\n<p>js建立execution context有兩個步驟</p>\\n<ol>\\n<li>建立階段</li>\\n<li>執行階段</li>\\n</ol>\\n<h4>建立階段</h4>\\n<ol>\\n<li>建立activation object or the variable object\\nvariable object指的是存放execution context scope data的物件，是一個抽象的概念，在不同的\\bcontext裡面實作方式(存放的東西)是不一樣的。\\n在global context中的variable object等同於自己，並且可以直接對變數引用，所以你能向下面一樣呼叫</li>\\n</ol>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code class=\\\"language-js\\\"><span class=\\\"token keyword\\\">var</span> a <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">String</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'test'</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n\\n<span class=\\\"token function\\\">alert</span><span class=\\\"token punctuation\\\">(</span>a<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span> <span class=\\\"token comment\\\">// directly, is found in VO(globalContext): \\\"test\\\"</span>\\n\\n<span class=\\\"token function\\\">alert</span><span class=\\\"token punctuation\\\">(</span>window<span class=\\\"token punctuation\\\">[</span><span class=\\\"token string\\\">'a'</span><span class=\\\"token punctuation\\\">]</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span> <span class=\\\"token comment\\\">// indirectly via global === VO(globalContext): \\\"test\\\"</span>\\n<span class=\\\"token function\\\">alert</span><span class=\\\"token punctuation\\\">(</span>a <span class=\\\"token operator\\\">===</span> <span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span>a<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span> <span class=\\\"token comment\\\">// true</span></code></pre>\\n      </div>\\n<p>在function \\bcontext中的VO稱之activation object，不能直接被引用，裡面要放入function arguments，context的var與function定義。</p>\\n<ul>\\n<li>\\n<p>對於每一個var，js會幫AO create一個property with value undefined，如果存在property就略過。</p>\\n</li>\\n<li>\\n<p>建立property for arg，把arguments object丟進去(reference)</p>\\n</li>\\n<li>\\n<p>對於function，js會create一個function，然後create property by function name，然後將ref丟進去，如果存在property就覆蓋。</p>\\n</li>\\n<li>\\n<p>建立scope chain\\n想像成一個array或是list，將裡面塞入VO(包涵現在所在的) [bFunc VO, a FuncVO, Global VO]\\n(es5會產生global scope, function scope，es6 let會產生block scope)</p>\\n</li>\\n<li>\\n<p>確認this的指向。</p>\\n</li>\\n</ul>\\n<p>最後</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code class=\\\"language-js\\\">executionContextObj <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">{</span>\\n    scopeChain<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token punctuation\\\">{</span> <span class=\\\"token comment\\\">/* variableObject + all parent execution context's variableObject */</span> <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">,</span>\\n    variableObject<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token punctuation\\\">{</span> <span class=\\\"token comment\\\">/* function arguments / parameters, inner variable and function declarations */</span> <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">,</span>\\n    <span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">:</span> <span class=\\\"token punctuation\\\">{</span><span class=\\\"token punctuation\\\">}</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n\\n<span class=\\\"token comment\\\">// example</span>\\nFuncExecutionContextObj <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">{</span>\\n  activationbj<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token punctuation\\\">{</span>\\n      argumentObj <span class=\\\"token punctuation\\\">:</span> <span class=\\\"token punctuation\\\">{</span>\\n          <span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">:</span> e<span class=\\\"token punctuation\\\">,</span>\\n          length<span class=\\\"token punctuation\\\">:</span><span class=\\\"token number\\\">1</span>\\n      <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">,</span>\\n      a<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token number\\\">10</span><span class=\\\"token punctuation\\\">,</span>\\n      b<span class=\\\"token punctuation\\\">:</span> undefined<span class=\\\"token punctuation\\\">,</span>\\n      c<span class=\\\"token punctuation\\\">:</span> undefined\\n      Func<span class=\\\"token punctuation\\\">:</span> Pointer to the Function definition<span class=\\\"token punctuation\\\">,</span>\\n  <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">,</span>\\n  scopeChain<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token punctuation\\\">[</span>Func variable object<span class=\\\"token punctuation\\\">,</span> Global exection context variable object<span class=\\\"token punctuation\\\">]</span><span class=\\\"token punctuation\\\">,</span>\\n  <span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">:</span> value <span class=\\\"token keyword\\\">of</span> <span class=\\\"token keyword\\\">this</span>\\n<span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<h4>執行階段</h4>\\n<p>從上逐步執行每一行code，若是跑到變數宣告才會賦值。</p>\\n<p>不過這樣很容易解釋</p>\\n<ol>\\n<li>var hoisting，因為create stage就已經知道變數了</li>\\n<li>var hoisting但呼叫var時為undefined，因為實際給值的動作可能在呼叫之後</li>\\n<li>function hoisting但能呼叫，因為function的處理方式是不一樣的</li>\\n<li>function expression與function declaration是不一樣的，function declaration視為var 宣告，在執行階段跑到變數宣告才會create function</li>\\n</ol>\\n<p>寫完文章才理解大家常常在說的上下文是\\\"context\\\"(翻了中英對照才知道...)，實作中比較常會遇到this的指向問題，這邊並沒有多做著磨，我們應該少使用一些反模式就可以大幅減少遇到問題的可能性，像多用es6 module與arrow function就是一種好的寫法(大部份的function不用dynamic this對吧)，有一些this太刁鑽了，想要的看<a href=\\\"https://halfrost.com/javascript_this/\\\">這裡</a>。</p>\\n<h4>後記</h4>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code class=\\\"language-js\\\"><span class=\\\"token keyword\\\">var</span> a <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token function\\\">b</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">const</span> c <span class=\\\"token operator\\\">=</span> <span class=\\\"token string\\\">'12'</span><span class=\\\"token punctuation\\\">;</span>\\n    console<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token keyword\\\">function</span> <span class=\\\"token function\\\">d</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n      console<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span>c<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n      console<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token punctuation\\\">}</span>\\n    <span class=\\\"token function\\\">d</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n  <span class=\\\"token punctuation\\\">}</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n\\na<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">b</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n\\n<span class=\\\"token comment\\\">// {b: ƒ}</span>\\n<span class=\\\"token comment\\\">// 12</span>\\n<span class=\\\"token comment\\\">// Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, frames: Window, …}</span></code></pre>\\n      </div>\\n<p>\\bthis的指向是跟著context的，而讀取變數是跟著scope的，上面範例，在執行d的時候，實際執行者是window，但變數是跟著scope chain所以能讀到c = 12。我發現之前我理解錯誤，我把\\bcontext與execution context連想在一起，但在javascript這兩個詞應該是不一樣的(好模糊啊)，execution context是scope VO加上\\\"context\\\"指向的this，所以我認為d是由b執行的，所以該指向execution context的this，但execution context實際上並沒有this的值，只有確認this的綁定。以d()來說，invoke一個unbounded function，其context指向global(\\bglobal.d())，而execution context把global存起來，再想到callback形式的寫法( arr.map(function(){ }) )，就能得知其實是一樣的道理。</p>\\n<h4>Context vs. Scope</h4>\\n<blockquote>\\n<p>The first important thing to clear up is that context and scope are not the same. I have noticed many developers over the years often confuse the two terms (myself included), incorrectly describing one for the other. To be fair, the terminology has become quite muddled over the years.</p>\\n</blockquote>\\n<blockquote>\\n<p>Every function invocation has both a scope and a context associated with it. Fundamentally, scope is function-based while context is object-based. In other words, scope pertains to the variable access of a function when it is invoked and is unique to each invocation. Context is always the value of the this keyword which is a reference to the object that “owns” the currently executing code.</p>\\n</blockquote>\"}},{\"node\":{\"fields\":{\"slug\":\"/posts/browser-mechanic/\"},\"frontmatter\":{\"title\":\"Browser render & performance\",\"date\":\"2018-03-25T15:29\",\"tags\":[\"mechanic\",\"performance tuning\"],\"release\":true},\"html\":\"<snippet>\\n  原本要介紹javascript event loop的，寫一寫變成介紹browserXDD\\n</snippet>\\n<p>有人問在處理器\\bloading js會block render是為什麼，我知道js是single thread，但並不能確定是single thread的問題，於是乎一切要從browser講起。</p>\\n<p>modern browser通常是multi process的，自己認為最大的優點是</p>\\n<ul>\\n<li>避免一頁crash而導致整個browser crash</li>\\n<li>避免插件crash而導致整個browser crash</li>\\n</ul>\\n<p>而對於前端最重要的就是渲染進程(process)，而一個process又可以分成multi thread，而渲染進程裡面擁有的重要thread</p>\\n<ul>\\n<li>GUI</li>\\n<li>JS</li>\\n<li>Event</li>\\n<li>Timer</li>\\n<li>Http request</li>\\n</ul>\\n<p>GUI與JS \\bthread是戶斥的，因為當repaint的時候會觸發GUI \\bthread，但JS執行後很有可能會造成多次repaint，於是乎JS在執行的時候會先block GUI thread，待JS結束後才換GUI thread。</p>\\n<p>所以如果在browser裡需要做密集運算可以使用web worker，browser會開一個子thread用來處理運算，但是不能操作dom，這是一個很酷的功能，目前的專案有地方可以優化的，只是browser的支援度還不夠所以放棄(IE 11 up...)，希望未來有機會玩囉。</p>\\n<p>假設我們發送了一個http request，browser的行為大致如下</p>\\n<ol>\\n<li>Get content from http request</li>\\n<li>Parse html and create dom tree (trigger DOMContentLoaded)</li>\\n<li>Parse css and create render tree(with dom tree)</li>\\n<li>(Layout/Reflow) the render tree</li>\\n<li>Paint the render tree</li>\\n<li>Composite &#x26; show on screen (trigger load)</li>\\n</ol>\\n<p>\\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block; ; max-width: 590px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 48.701298701298704%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABYlAAAWJQFJUiTwAAAB6UlEQVQoz11SXW+bMBTNz9/jtP2Bve1h+wd7qKpulaZoSqONkLZAIBAgJkAwBgM2nF3cJWp3pKvra1+f+7kAoSgqdLKZj+gahor9wjj2xh5HbXR1Lskvp9OEKyZt7GkajcxYiOIPTukG7QDMzyf2DG/1Hn0nrv8GevCCBJ4foeqAutiijO8M9fiaf5qwODx9Rex8Qcs9SBEhi27BCweKArZSgLOflD2HkCPqVlPwNfncIWcWWHiDlioqku9Qjf+SYcsDiCqA49pIEhcH6wNOeQo/bsCOLoKHd6jPIRJWYReVSPY/wJxPyMsC69U3hHGMrb3Ek/NoKlmYPpHUEjgwActawt3tUNQaspPom9BoP8oQkDgBw2azxHNwxDHvUPABrJCIGYfSVHLfddCKGkhN5ULidJakezI1Rq2Mk1KKhjOaAaUsxy7MkJ+FGYrWA90r4296ODsyxhBT6j1lMqNuFI5ZhZyPZlgsy9F1Pd6CAmn9L9CLGML5ac5Ak8hBwUtDrJ5s+MczCmbTNG+IrDX94ac1RHb/ZnP+x2JmvWAmtIJH2CROzLEPfiPa3WKf5JAKyLzPSO2PKBsJN/bhJgH9Ga4rYzK8HF4TzxBNj5IaXtPepaykjxM67kCWGzAu8OBZ2EYBOqrsQjjjL3B7+wLRL+N4AAAAAElFTkSuQmCC'); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"RenderTree\\\"\\n        title=\\\"\\\"\\n        src=\\\"/static/RenderTree-7efd7b826a452eb48175a6d2846a6b1f-a408b.png\\\"\\n        srcset=\\\"/static/RenderTree-7efd7b826a452eb48175a6d2846a6b1f-4eabf.png 148w,\\n/static/RenderTree-7efd7b826a452eb48175a6d2846a6b1f-5a375.png 295w,\\n/static/RenderTree-7efd7b826a452eb48175a6d2846a6b1f-a408b.png 590w,\\n/static/RenderTree-7efd7b826a452eb48175a6d2846a6b1f-9a0cc.png 885w,\\n/static/RenderTree-7efd7b826a452eb48175a6d2846a6b1f-aa987.png 1180w,\\n/static/RenderTree-7efd7b826a452eb48175a6d2846a6b1f-c00d7.png 1540w\\\"\\n        sizes=\\\"(max-width: 590px) 100vw, 590px\\\"\\n      />\\n    </span>\\n  </span>\\n  </p>\\n<p>原本我知道javascript要放在body之後或是寫上defer，這邊我才發現css也會block render(dom tree ok，但render tree不行)，但是為了first time render，所以css一定要放在head，但如果很大要進行特殊處理，這邊有另一個領域叫critical render path(因為main css屬於critical但\\bjs不是，所以js可以慢load)。</p>\\n<p>(這就非常有趣了，首先我不知道webpack包裝成的SPA是怎麼處理css的，另外就是css in jsx，loader，styled-Component各會造成怎樣的效果。之後研究的目標之一)</p>\\n<p>composite是另一個很有趣的概念，首先要先了解render pipeline</p>\\n<p>\\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block; ; max-width: 590px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 10.91160220994475%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAYAAABYBvyLAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAm0lEQVQI1yXMTwvBYADAYV/SyUXtMAelltZIS2YbRpJ8ArZx22VZmLO/RydHpU2U9xP8LDs9t6cgzmXEWUJcK4iLxPckEczueMM3npOwGqe4gwTfeeFPHliRjhmrGNs69r7519yp2HGD1rpKQRxLeXSR8/hQJJjecJ0Pi16SZXm4HKXM+0+6oY4RK+hRjU6WtTcKVqxlYRMtlPkB1Q51jFyu9xUAAAAASUVORK5CYII='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"render_pipeline\\\"\\n        title=\\\"\\\"\\n        src=\\\"/static/render_pipeline-18578f2ae7d686d16ac1ea1bc606f83c-a408b.png\\\"\\n        srcset=\\\"/static/render_pipeline-18578f2ae7d686d16ac1ea1bc606f83c-4eabf.png 148w,\\n/static/render_pipeline-18578f2ae7d686d16ac1ea1bc606f83c-5a375.png 295w,\\n/static/render_pipeline-18578f2ae7d686d16ac1ea1bc606f83c-a408b.png 590w,\\n/static/render_pipeline-18578f2ae7d686d16ac1ea1bc606f83c-9a0cc.png 885w,\\n/static/render_pipeline-18578f2ae7d686d16ac1ea1bc606f83c-aa987.png 1180w,\\n/static/render_pipeline-18578f2ae7d686d16ac1ea1bc606f83c-52bff.png 1448w\\\"\\n        sizes=\\\"(max-width: 590px) 100vw, 590px\\\"\\n      />\\n    </span>\\n  </span>\\n  </p>\\n<p>在前端的渲染機制是這樣</p>\\n<ul>\\n<li>Javascript - trigger event</li>\\n<li>Style - css selector</li>\\n<li>Layout - calculate Layout</li>\\n<li>Paint - fill pixel</li>\\n<li>Composite - layer merge</li>\\n</ul>\\n<p>只介紹後面三個，跟頁面排版有關的東西會重新計算(width, height, left...)，此種行為觸發layout，跟繪制有關的觸發paint(color, border...)，跟layer有關的觸發composite，這是一個pipeline，但不是每一個都要經過，經過越少step的效能越好。而通常在一個沒有特別設置的頁面只會有一個layer(或是browser預設的layer?待求證)，但我們可以用tranform, translate 3d, will-change等去特別制造一個layer出來，最後composite的時候就會組合起來。所以就以純移動來講，使用tranform(\\bStyle -> Composite)比left(\\bStyle -> Layout -> Paint -> Composite)好，但實際使用一個頁面太多layer反而會降低效率，所以這又很吃應用場景。</p>\\n<p>當你修改了某些css的style，會產生不同的cost。這邊有份<a href=\\\"https://www.slideshare.net/ApoorvSaxena/performance-beyond-page-load\\\">簡報</a>，甚至你可以到<a href=\\\"https://csstriggers.com/\\\">css trigger</a>查詢。</p>\\n<p>(這邊也非常有趣，沒有實際優化過，不過用過一兩次will-change)</p>\\n<p>PS. 其實大部份的概念來自<a href=\\\"http://www.dailichun.com/2018/01/21/js_singlethread_eventloop.html\\\">這篇文章</a>，建議好好的看過文章，因為我的版本省略了很多介紹XD</p>\\n<p>不過以上介紹的東西在現代的前端開發(SPA component...)還需要再釐清，很多都是3-4年前的推廣，像是css建議多用class而不要js控制，但jsx推崇css in js，另外在render部份使用vdom技術，加上使用webpack打包會不會已經不用關注某些問題值得再討論。</p>\"}},{\"node\":{\"fields\":{\"slug\":\"/posts/new-year-wish/\"},\"frontmatter\":{\"title\":\"New Year Wish\",\"date\":\"2018-02-20T18:06\",\"tags\":[\"nothing special\"],\"release\":true},\"html\":\"<snippet>\\n  新年到了，該給自己一個目標。\\n</snippet>\\n<p>原本是想要每個月寫一篇文章的，但是人都有惰性(\\bx)。</p>\\n<p>最近也在凖備轉職，從面試中也得知了許多自己的不足，雖然我知道這些問題可能都是拿來壓薪水的XD</p>\\n<p>近期也幫了公司導入unit test，因為要做教育訓練，也花了時間做投影片。從那些似曾相似的題目，從為了教育訓練而認真研究，能了解到一件事情。會用跟知道原理完全是兩回事，很多時候就覺得就是這樣，但說不出個所以然，感覺就很javavscript，因為javascript就是一個這麼不嚴格的語言XD</p>\\n<p>import module用慣了，套件用久了，react寫多了，這麼的declative，反而造成了只知道怎麼用，而不知道原因。目前短期先把javascript的重要概念先補完吧，同時想要解決兩件事情，第一，當有人問起時，可以完整的告知原因，而不是隨便呼嚨兩句，第二，也是我最一開始的理想，把那些常忘記的事情記錄，會常忘記就是因為每次都好像是這樣，大概是這樣。</p>\\n<p>這次增加了一頁TODO LIST，不記錄一下，我連想寫什麼文章都要忘了。</p>\\n<p>原本的夢想是成為一個優秀的前端工程師，開著chrome dev tools，為使用者的0.01秒而奮鬥，但是在台灣的工作中好像沒有看過，大部份都是開發速度導向，當然我開發上也還有進步的空間，不過今年看到印象最深刻的還是react 0.16頁面中的<a href=\\\"https://medium.com/@paularmstrong/twitter-lite-and-high-performance-react-progressive-web-apps-at-scale-d28a00e780a3\\\">twitter PWA tunning</a>。</p>\\n<p>當然新年還是要玩一些新東西，還在想要朝向isomorphic還是react-native邁進。react-native比起以前已經相對的成熟了，通常做app更講究使用者體驗，也是我更有興趣的一部份，但是fullstack在職涯上有絕對的優勢，自己寫過過往的full stack mvc，也改過公司後台的nodejs(refactor一些東西)，非常不認同前端是比較簡單的工作(薪水比較低)，只是注意的點是不一樣的，我更在意的是使用者會如何跟我的介面互動，這就好像設計不值錢這種謬論是一樣的。</p>\\n<p>最後，今年應該是兩個都會碰一下，不過主要玩isomorphic &#x26; backend相關技術，這與我幾年後的目標比較match，當然最終可以react-native + isomorphic，等到時候再說吧，前端技術，每18個月重來一次呢。</p>\"}}]}},\"pathContext\":{\"offset\":0,\"paginations\":6,\"total\":26}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---index-14d55be14fdd7056a890.js","module.exports = {\"data\":{\"allMarkdownRemark\":{\"edges\":[{\"node\":{\"fields\":{\"slug\":\"/posts/webpack-manifest-n-chunk/\"},\"frontmatter\":{\"title\":\"webpack production part 下(chunk & manifest)\",\"date\":\"2018-10-14T16:56\",\"tags\":[\"webpack\"],\"release\":true},\"html\":\"<snippet>\\n  此篇為雜記，我想到啥就記啥。主要的話會跟js caching有關\\n  此篇webpack為4.x version\\n</snippet>\\n<p>在前端領域中，bundle是很重要的，dev build跟production build大小，我舉例手上的專案，9mb -> 3xx kb(gzip)。</p>\\n<p>關於檔案大小的部份不在此介紹中。這應該是比較簡單的part，只要你mode有開prodction應該就差很多了。\\n(好吧 我想寫caching 上集晚點補)</p>\\n<p>靜態檔案cache是一個很重要的機制，cache的好，使用者不用每次進網頁都載一次檔案。這點在前端蠻容易被忽略的(至少對於我本人)。在本地端開發的時候很少會感受到file size的影響，上了production習慣開dev tool + disable cached。</p>\\n<p>cache通常會提到server設定，不過我們這邊要提的如何讓webpack做long term cache</p>\\n<p>首先要知道的就是一般使用webpack output file會長這樣</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code class=\\\"language-js\\\">output<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token punctuation\\\">{</span>\\n  filename<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token string\\\">'[name].[chunkhash].js'</span><span class=\\\"token punctuation\\\">,</span>\\n  path<span class=\\\"token punctuation\\\">:</span> path<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">resolve</span><span class=\\\"token punctuation\\\">(</span>__dirname<span class=\\\"token punctuation\\\">,</span> <span class=\\\"token string\\\">'../dist'</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">,</span>\\n<span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">,</span></code></pre>\\n      </div>\\n<br/>\\n<p><strong>為什麼要加hash</strong></p>\\n<p>基於正常使用者不會每次進入頁面都clean cached，若是今天線上版的foo.js要更新</p>\\n<p>client端看到foo.js名稱一樣使用舊的cache，後果不堪設想。(頁面極度容易掛掉)</p>\\n<p>所以每次build的時候依據檔案的內容產生不一樣的的md5加在後面，client端看到不一樣的檔案名稱就會抓取新的檔案</p>\\n<p>為啥不用 static.file?v=xx.xx.xx 可以看參考</p>\\n<p>好解法=使用hash file name 先佈static file再佈頁面</p>\\n<p>這是如果有使用cdn之類的功能的話，如果是docker一起丟file+html是沒差的</p>\\n<p>請視狀況而定</p>\\n<p>long term caching講的是如何在每次佈版的時候，只針對最少的js改動(其他保留不變)</p>\\n<br />\\n<h3>hash &#x26;&#x26; chunkhash</h3>\\n<p>了解這兩個的差異是開始的第一步</p>\\n<p>不過自行了解一下code splitting(我好像沒介紹)</p>\\n<p>對於hash，計算所有chunks的hash，也就是所有檔案後面接的hash會一樣</p>\\n<p>對於chunkhash，每個chunk單獨計算hash</p>\\n<blockquote>\\n<p>不用在dev放上hash，會增加build的時間</p>\\n</blockquote>\\n<p>我們希望當只有一個檔案更新的時候使用者只需要抓一個檔案，想當然要用chunkhash</p>\\n<p>至於有使用ExtractTextPlugin的人可以google一下content-hash</p>\\n<p>因為我們在新的專案使用styled components所以沒有這個問題</p>\\n<p><br/><br/></p>\\n<p>這麼簡單的結束了嗎(X)</p>\\n<p>實際在做旳時候，就算是某檔案完全沒更動也是換了hash value。</p>\\n<p>上網查了後，我們還需要了解manifest與runtime</p>\\n<h4>runtime</h4>\\n<p>webpack在連接所有的code與module相依時(js load完了沒，這module需要啥其他module)，會需要一段code來做這些事情，而這段code就稱之runtime</p>\\n<h4>manifest</h4>\\n<p>當你寫著import, require，compile之後會變成webpack的module，在code裡面常常看到樣的code</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code class=\\\"language-js\\\"><span class=\\\"token function\\\">__webpack_require__</span><span class=\\\"token punctuation\\\">(</span>id<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token comment\\\">// &lt;&lt;&lt; id</span></code></pre>\\n      </div>\\n<p>而什麼module對應什麼id這些就是manifest做的</p>\\n<p>當你新增或刪除module, module排列的id會變動，這些東西寫在chunk裡面每次就需要rebuild。</p>\\n<p>在webpack4中，可以設置runChunk: true，會將runtime與manifest拉出來(each entry has a runtime)</p>\\n<p>這樣可以確保剩下的code之中不會挾雜其他\\b的module id</p>\\n<blockquote>\\n<p>webpack 4.x 沒有 CommonsChunkPlugin</p>\\n</blockquote>\\n<br />\\n<p>另外對於manifest，拉出來還不夠看。</p>\\n<p>webpack預設module是name by id(integer)</p>\\n<p>假設現在有 1 , 2 , 3, ,4 ,5 module</p>\\n<p>插入了新的module被歸類在3</p>\\n<p>1不變, 2不變, 3 new, 4 -> original 3, 5 -> original 4, 6, -> original 5</p>\\n<p>這樣子就rebuild了original 3, 4, 5</p>\\n<p>所以我們還會引入NamedModulesPlugin, HashedModuleIdsPlugin</p>\\n<p>一樣是用內容轉成hash，就算上述的事情發生，只需要build new or modified module and rebuild runtimeChunk使用者也不用重新loading file</p>\\n<br/>\\n<p>最後的配置(簡單的)</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code class=\\\"language-js\\\">output<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token punctuation\\\">{</span>\\n  filename<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token string\\\">'[name].[chunkhash].js'</span><span class=\\\"token punctuation\\\">,</span>\\n  path<span class=\\\"token punctuation\\\">:</span> path<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">resolve</span><span class=\\\"token punctuation\\\">(</span>__dirname<span class=\\\"token punctuation\\\">,</span> <span class=\\\"token string\\\">'../dist'</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">,</span>\\n<span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">,</span>\\noptimization<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token punctuation\\\">{</span>\\n  runtimeChunk<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token boolean\\\">true</span><span class=\\\"token punctuation\\\">,</span>  <span class=\\\"token comment\\\">// this line</span>\\n  splitChunks<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token punctuation\\\">{</span>\\n    chunks<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token string\\\">'async'</span><span class=\\\"token punctuation\\\">,</span>\\n    name<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token boolean\\\">true</span><span class=\\\"token punctuation\\\">,</span>\\n    cacheGroups<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token punctuation\\\">{</span> <span class=\\\"token comment\\\">// can do more if you have complex SPA</span>\\n      vendors<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token punctuation\\\">{</span>\\n        test<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token regex\\\">/[\\\\\\\\/]node_modules[\\\\\\\\/]/</span><span class=\\\"token punctuation\\\">,</span>\\n        name<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token string\\\">'vendors'</span><span class=\\\"token punctuation\\\">,</span>\\n        chunks<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token string\\\">'all'</span>\\n      <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">,</span>\\n      components<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token punctuation\\\">{</span>\\n        test<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token regex\\\">/[\\\\\\\\/]components[\\\\\\\\/]/</span><span class=\\\"token punctuation\\\">,</span>\\n        name<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token string\\\">'components'</span><span class=\\\"token punctuation\\\">,</span>\\n        chunks<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token string\\\">'all'</span>\\n      <span class=\\\"token punctuation\\\">}</span>\\n    <span class=\\\"token punctuation\\\">}</span>\\n  <span class=\\\"token punctuation\\\">}</span>\\n<span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">,</span>\\nplugins<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token punctuation\\\">[</span>\\n  <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">webpack<span class=\\\"token punctuation\\\">.</span>HashedModuleIdsPlugin</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">,</span> <span class=\\\"token comment\\\">// this line</span>\\n<span class=\\\"token punctuation\\\">]</span><span class=\\\"token punctuation\\\">,</span></code></pre>\\n      </div>\\n<p>想知道更深的進去參考挖吧</p>\\n<p><a href=\\\"https://www.zhihu.com/question/20790576/answer/32602154\\\">參考1 非常有用</a></p>\\n<p><a href=\\\"https://github.com/pigcan/blog/issues/9\\\">參考2 非常有用</a></p>\"}},{\"node\":{\"fields\":{\"slug\":\"/posts/script-after-body/\"},\"frontmatter\":{\"title\":\"JS CSS in body( position)\",\"date\":\"2018-09-02T17:45\",\"tags\":[\"mechanic\"],\"release\":true},\"html\":\"<snippet>\\n  天啊，原本預計一個月一篇文章，由於本人跑去當了full stack，變得太忙了，周末只想好好休息耍廢。最近新專案終於要上了，處理的也差不多了。只剩一些小bug與performance需要調整我會想辨法，我會努力把文章補回。未來再來看看要不要加一些後端文章(那就不是前端小誌了XD)\\n</snippet>\\n<p>這篇先來個簡單的東西吧，就是script tag, link到底要放在html的哪裡呢</p>\\n<p>直接先講結論</p>\\n<blockquote>\\n<p>放在body之後絕對沒毛病</p>\\n</blockquote>\\n<p>從最簡單講起，大多數人一定知道loading js會block browser的render機制</p>\\n<p>很多<a href=\\\"/posts/browser-mechanic/\\\">之前</a>的概念要知道</p>\\n<blockquote>\\n<p>GUI與JS \\bthread是戶斥的，因為當repaint的時候會觸發GUI \\bthread，但JS執行後很有可能會造成多次repaint，於是乎JS在執行的時候會先block GUI thread，待JS結束後才換GUI thread。</p>\\n</blockquote>\\n<p>於似乎我們可以用async defer這兩個關鍵字去處理，這蠻簡單的，直接看圖吧</p>\\n<p>\\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block; ; max-width: 590px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 55.00921942224954%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAEF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAB3bQB/8QAFBABAAAAAAAAAAAAAAAAAAAAIP/aAAgBAQABBQJf/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFBABAAAAAAAAAAAAAAAAAAAAIP/aAAgBAQAGPwJf/8QAGRAAAwADAAAAAAAAAAAAAAAAABARAZHw/9oACAEBAAE/IcdDahF//9oADAMBAAIAAwAAABBDz//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EAB0QAAIBBAMAAAAAAAAAAAAAAAABESExUYFxkdH/2gAIAQEAAT8Qa6VOUsU47C3shHjEmBKD/9k='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"js_async_n_defer\\\"\\n        title=\\\"\\\"\\n        src=\\\"/static/js_async_n_defer-8fb190e9baa4e48eb996dd90c239547b-ca545.jpg\\\"\\n        srcset=\\\"/static/js_async_n_defer-8fb190e9baa4e48eb996dd90c239547b-aa1b7.jpg 148w,\\n/static/js_async_n_defer-8fb190e9baa4e48eb996dd90c239547b-b937a.jpg 295w,\\n/static/js_async_n_defer-8fb190e9baa4e48eb996dd90c239547b-ca545.jpg 590w,\\n/static/js_async_n_defer-8fb190e9baa4e48eb996dd90c239547b-75639.jpg 885w,\\n/static/js_async_n_defer-8fb190e9baa4e48eb996dd90c239547b-8bd51.jpg 1180w,\\n/static/js_async_n_defer-8fb190e9baa4e48eb996dd90c239547b-868d3.jpg 1627w\\\"\\n        sizes=\\\"(max-width: 590px) 100vw, 590px\\\"\\n      />\\n    </span>\\n  </span>\\n  </p>\\n<p>如果使用了defer，放在header跟body後就根本沒差別了，其他的case放在body後是個保險的寫法</p>\\n<p>但有一個很重要的點</p>\\n<p><font color='red'><strong>defer不保証執行順序 defer不保証執行順序 defer不保証執行順序(由上到下)</strong></font></p>\\n<p>實際上碰到的，專案裡有一個external file是公司寫好的logger module(es5 CMD)，並不是build在webpack的entry裡。</p>\\n<p>原本是兩個檔案 A &#x26; B</p>\\n<p>因為defer不保証順序，所以我這樣寫</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-html\\\"><code class=\\\"language-html\\\"><span class=\\\"token tag\\\"><span class=\\\"token tag\\\"><span class=\\\"token punctuation\\\">&lt;</span>header</span><span class=\\\"token punctuation\\\">></span></span>\\n  <span class=\\\"token tag\\\"><span class=\\\"token tag\\\"><span class=\\\"token punctuation\\\">&lt;</span>script</span> <span class=\\\"token attr-name\\\">async</span> <span class=\\\"token attr-name\\\">src</span><span class=\\\"token attr-value\\\"><span class=\\\"token punctuation\\\">=</span><span class=\\\"token punctuation\\\">'</span>a.js<span class=\\\"token punctuation\\\">'</span></span><span class=\\\"token punctuation\\\">></span></span><span class=\\\"token script language-javascript\\\"></span><span class=\\\"token tag\\\"><span class=\\\"token tag\\\"><span class=\\\"token punctuation\\\">&lt;/</span>script</span><span class=\\\"token punctuation\\\">></span></span>\\n<span class=\\\"token tag\\\"><span class=\\\"token tag\\\"><span class=\\\"token punctuation\\\">&lt;/</span>header</span><span class=\\\"token punctuation\\\">></span></span>\\n<span class=\\\"token tag\\\"><span class=\\\"token tag\\\"><span class=\\\"token punctuation\\\">&lt;</span>body</span><span class=\\\"token punctuation\\\">></span></span>\\n<span class=\\\"token tag\\\"><span class=\\\"token tag\\\"><span class=\\\"token punctuation\\\">&lt;/</span>body</span><span class=\\\"token punctuation\\\">></span></span>\\n  <span class=\\\"token tag\\\"><span class=\\\"token tag\\\"><span class=\\\"token punctuation\\\">&lt;</span>script</span> <span class=\\\"token attr-name\\\">defer</span> <span class=\\\"token attr-name\\\">src</span><span class=\\\"token attr-value\\\"><span class=\\\"token punctuation\\\">=</span><span class=\\\"token punctuation\\\">'</span>b.js<span class=\\\"token punctuation\\\">'</span></span><span class=\\\"token punctuation\\\">></span></span><span class=\\\"token script language-javascript\\\"></span><span class=\\\"token tag\\\"><span class=\\\"token tag\\\"><span class=\\\"token punctuation\\\">&lt;/</span>script</span><span class=\\\"token punctuation\\\">></span></span></code></pre>\\n      </div>\\n<p>async load完就執行，defer要等到DOMContentLoaded之前執行</p>\\n<p>覺得OK(X) 好像失敗了(O)</p>\\n<p>在正常開發人員always clean cache every refresh下完全ok</p>\\n<p>但是在browser有cache的情況下，不保証執行順序就炸了(都是0秒 loading time)</p>\\n<p>最後的解法是將兩個檔案放在一起(在最後的版本我開了一個webpack entry還是bundle了)</p>\\n<p><br/><br/></p>\\n<p>寫到這裡，先轉個話題談談css</p>\\n<p>為什麼css必須放在header呢</p>\\n<p>原因是css屬於關鍵渲染路徑(critical render path)中的一環</p>\\n<p>過慢的loading會delay domContentLoaded的時間，而因為網頁的評分中將未加載css的網頁視為沒載完(因為很醜無法閱讀)，沒辨法跟js一樣async loading</p>\\n<p>這篇<a href=\\\"https://www.cnblogs.com/libin-1/p/7127330.html\\\">文章</a>說的很好，配上上面的之前文章，直接拿結論</p>\\n<ol>\\n<li>css 不會影響dom tree parsing</li>\\n<li>css 會影響 dom tree rendering(因為css dom tree還沒建好)</li>\\n<li>css 與js互斥，原因上面講了</li>\\n</ol>\\n<p>隨便提一個 do not use @import(我用google font的時候被偵測到)，原因是又delay loading</p>\\n<p>(之後開個文章把所有有用的tunning都寫進去)</p>\\n<p>又回到js部份，這也是真的該理解的部份</p>\\n<p>既然js會block render，那反正js放header跟放body後不都一樣</p>\\n<p>這說法是對的也是錯的。</p>\\n<p>如果所謂的block render指的是complete anything and can intereact with users 那答案是yes，根本就沒差</p>\\n<p>tricky的地方其實是我們關心的是first time render view，而dom tree會在一個網頁被開啟時被重覆更新好幾次(only by js, css必定先讀完)</p>\\n<p>我在網頁文章中的理解是css dom tree的parse決定第一次paint的時間(css 不會影響dom tree parsing，會影響 dom tree rendering)結束parse才觸發js執行，而parse js的行為是會先將js前面的已經ok的dom先paint過一次</p>\\n<ol>\\n<li>css loading time > js loading time 畫面白掉無法paint</li>\\n<li>css loading time &#x3C; js loading time paint到js的那行之前</li>\\n</ol>\\n<p>所以假設</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-html\\\"><code class=\\\"language-html\\\"><span class=\\\"token tag\\\"><span class=\\\"token tag\\\"><span class=\\\"token punctuation\\\">&lt;</span>html</span><span class=\\\"token punctuation\\\">></span></span>\\n  <span class=\\\"token tag\\\"><span class=\\\"token tag\\\"><span class=\\\"token punctuation\\\">&lt;</span>nav</span><span class=\\\"token punctuation\\\">></span></span><span class=\\\"token tag\\\"><span class=\\\"token tag\\\"><span class=\\\"token punctuation\\\">&lt;/</span>nav</span><span class=\\\"token punctuation\\\">></span></span>\\n  <span class=\\\"token tag\\\"><span class=\\\"token tag\\\"><span class=\\\"token punctuation\\\">&lt;</span>script</span> <span class=\\\"token punctuation\\\">></span></span><span class=\\\"token script language-javascript\\\"> heavy js</span><span class=\\\"token tag\\\"><span class=\\\"token tag\\\"><span class=\\\"token punctuation\\\">&lt;/</span>script</span><span class=\\\"token punctuation\\\">></span></span>\\n\\n\\n  <span class=\\\"token tag\\\"><span class=\\\"token tag\\\"><span class=\\\"token punctuation\\\">&lt;</span>body</span><span class=\\\"token punctuation\\\">></span></span>\\n    <span class=\\\"token tag\\\"><span class=\\\"token tag\\\"><span class=\\\"token punctuation\\\">&lt;</span>h1</span><span class=\\\"token punctuation\\\">></span></span><span class=\\\"token tag\\\"><span class=\\\"token tag\\\"><span class=\\\"token punctuation\\\">&lt;/</span>h1</span><span class=\\\"token punctuation\\\">></span></span>\\n    ...\\n    <span class=\\\"token tag\\\"><span class=\\\"token tag\\\"><span class=\\\"token punctuation\\\">&lt;</span>p</span><span class=\\\"token punctuation\\\">></span></span><span class=\\\"token tag\\\"><span class=\\\"token tag\\\"><span class=\\\"token punctuation\\\">&lt;/</span>p</span><span class=\\\"token punctuation\\\">></span></span>\\n  <span class=\\\"token tag\\\"><span class=\\\"token tag\\\"><span class=\\\"token punctuation\\\">&lt;/</span>body</span><span class=\\\"token punctuation\\\">></span></span>\\n<span class=\\\"token tag\\\"><span class=\\\"token tag\\\"><span class=\\\"token punctuation\\\">&lt;/</span>html</span><span class=\\\"token punctuation\\\">></span></span></code></pre>\\n      </div>\\n<p>js執行會阻止下方dom render</p>\\n<p>使用者會在first time render view只看到nav，經過了heavy js execute之後才會繼續向下。</p>\\n<p>那才是為什麼script要放body之後</p>\\n<p>這些東西我以前知道script放body之後，近期才真正弄懂它</p>\\n<br />\\n<p>不過最後思考一個問題，在spa的頁面中，請問script放在body之後有好處嗎</p>\\n<p>我的理解(請反白)</p>\\n<font color='white'>\\n沒啥鳥用，因為你的頁面是heavy js，first time render view = 空白 root element，除非有做ssr那就另當別論\\n</font>\\n<p>這算是老觀念了，我覺得有一些outdated的部份，所以才特別重新review與思考，充份了解還是聊勝於無啊。</p>\\n<p><a href=\\\"https://segmentfault.com/a/1190000004292479\\\">參考1</a></p>\\n<p><a href=\\\"https://segmentfault.com/a/1190000007766425\\\">參考2</a></p>\"}},{\"node\":{\"fields\":{\"slug\":\"/posts/javascript-memory/\"},\"frontmatter\":{\"title\":\"Javascript memory in use\",\"date\":\"2018-04-29T16:18\",\"tags\":[\"mechanic\"],\"release\":true},\"html\":\"<snippet>\\n  整個四月都在忙轉職的事情，而且跑去刷leetcode啦，結果要寫的東西越來越多啦，才發現我連event loop都還沒寫.\\n</snippet>\\n<p>這篇要介紹的是javascript的memory的機制，在認識event loop的時候知道的queue與stack，不過還缺一個heap，還可以順便提一下primitive與object。</p>\\n<p>在js的語言中，只有兩種資料型態</p>\\n<h4>primitive type - 基本型別</h4>\\n<p>\\b\\n包涵以下六種</p>\\n<ul>\\n<li>string</li>\\n<li>number</li>\\n<li>boolean</li>\\n<li>null</li>\\n<li>undefined</li>\\n<li>symbol(es6加入)</li>\\n</ul>\\n<h4>object - 物件 沒啥好說的</h4>\\n<p>在string、number、boolean與symbol有所謂的wrapper object(封裝物件?網路上很多種翻譯)</p>\\n<p>在使用這些primitive的時候，JS會臨時的create一個new [Type] object(ex: new Number(8))，然後進行操作完後就拋棄。請永遠不要用new的方式去初始化參數，原因是啥我忘了，大概在比較上有些不一樣的與速度比一般直接宣告慢。</p>\\n<p>也不要在primitive加properties，以下有一個很簡單的例子</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code class=\\\"language-js\\\"><span class=\\\"token keyword\\\">var</span> s <span class=\\\"token operator\\\">=</span> <span class=\\\"token string\\\">'Hello World'</span><span class=\\\"token punctuation\\\">;</span>\\ns<span class=\\\"token punctuation\\\">.</span>len <span class=\\\"token operator\\\">=</span> <span class=\\\"token string\\\">'len'</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token keyword\\\">var</span> t <span class=\\\"token operator\\\">=</span> s<span class=\\\"token punctuation\\\">.</span>len<span class=\\\"token punctuation\\\">;</span>\\n\\nconsole<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span>t<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token comment\\\">// undefined</span></code></pre>\\n      </div>\\n<p>因為每次操作的時候，都會產生一個新的object，然後就釋放掉，所以t的那行拿不到上一行s.len的值。</p>\\n<p>primitive是call by value的</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code class=\\\"language-js\\\"><span class=\\\"token keyword\\\">var</span> a <span class=\\\"token operator\\\">=</span> <span class=\\\"token number\\\">123</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token keyword\\\">var</span> b <span class=\\\"token operator\\\">=</span> a<span class=\\\"token punctuation\\\">;</span>\\nb <span class=\\\"token operator\\\">=</span> <span class=\\\"token number\\\">456</span><span class=\\\"token punctuation\\\">;</span>\\n\\nconsole<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span>a<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token comment\\\">// 123</span>\\nconsole<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span>b<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token comment\\\">// 456</span></code></pre>\\n      </div>\\n<p>object是call by reference的</p>\\n<p>array是normal object + \\\"special function\\\" 所以也是call by reference</p>\\n<p>然後function也是一種特殊object...(callable object)\\n(要記的清楚好麻煩XD)</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code class=\\\"language-js\\\"><span class=\\\"token keyword\\\">var</span> a <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">{</span>\\n  test<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token boolean\\\">true</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n<span class=\\\"token keyword\\\">var</span> b <span class=\\\"token operator\\\">=</span> a<span class=\\\"token punctuation\\\">;</span>\\n\\nb<span class=\\\"token punctuation\\\">.</span>test <span class=\\\"token operator\\\">=</span> <span class=\\\"token boolean\\\">false</span><span class=\\\"token punctuation\\\">;</span>\\n\\nconsole<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span>a<span class=\\\"token punctuation\\\">.</span>test<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token comment\\\">//false</span>\\nconsole<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span>b<span class=\\\"token punctuation\\\">.</span>test<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token comment\\\">//false</span></code></pre>\\n      </div>\\n<p>PS. 有人說更正確的為call by sharing</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code class=\\\"language-js\\\"><span class=\\\"token keyword\\\">var</span> bar<span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token keyword\\\">var</span> foo <span class=\\\"token operator\\\">=</span> bar<span class=\\\"token punctuation\\\">;</span>\\nbar <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">{</span><span class=\\\"token string\\\">'key'</span> <span class=\\\"token punctuation\\\">:</span> <span class=\\\"token string\\\">'value'</span><span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">;</span>\\nconsole<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span>foo <span class=\\\"token punctuation\\\">,</span> bar <span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n\\n<span class=\\\"token comment\\\">// if call by reference?</span></code></pre>\\n      </div>\\n<p>說的太深又是一篇文章，先略過吧。</p>\\n<br/>\\n<p>那進入我們的memory介紹</p>\\n<p>因為javascript是dynamic language，變數可能隨時改變型別，所以記憶體是動態分配的。</p>\\n<p>不管是primitive或是object皆儲存在heap記憶體中。</p>\\n<p>而stack會保存heap裡面變數的ref</p>\\n<p>\\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block; ; max-width: 590px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 73.875%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAABYlAAAWJQFJUiTwAAABkElEQVQ4y32T2WoDMQxF/f+/ljwmIStZCGQh+767PYJjpqXUIEYjS1fX8nXK3+v9fuf7/Z63222+Xq/x//l8wp7PZ/wbO5/PYa/XK8w9jJUoAIzNTqeTZ7NZ+LfbLT8ejzD2aQTgdDqNPPcul0t8yScvUUyAroPBIC+Xy2BFgqDkEMMHlIVPTJbiJBmMRqOw8Xic5/N5xA6HQzDDF5h/gQA3jgVDNi0CCCPRQuIwZRSwh02VtcA/ACnodrsxG2yxWJQEC4/HYz6dTn8CaXFkj4MBNplMytEEdCywIy6AZJwhftLp9/u53W7nVquVV6tVOZqyEVh5eGFVleAnrxv6HBUtOsNqdxl623y5xGazWWKFoTNBNrDc7XaFocYyV4aOq9okGOLArNFoRMfNZlM6OrfhcBg51Rt2hsaKsBE1YLVaLfd6vWDKJgXsAcgLQZfO8V/ZWITWYIc8eFJIRQas6msRSNAfsmGDm63X6yGd9XodQEqERIX++8gy9vjJ4cNmv9/HhWB2lSGNq09Q37jS+QL8qoxq3PmqzAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"stack_n_heap.png\\\"\\n        title=\\\"\\\"\\n        src=\\\"/static/stack_n_heap-90b51a4be5dbfff29bcca49d861a0e83-a408b.png\\\"\\n        srcset=\\\"/static/stack_n_heap-90b51a4be5dbfff29bcca49d861a0e83-4eabf.png 148w,\\n/static/stack_n_heap-90b51a4be5dbfff29bcca49d861a0e83-5a375.png 295w,\\n/static/stack_n_heap-90b51a4be5dbfff29bcca49d861a0e83-a408b.png 590w,\\n/static/stack_n_heap-90b51a4be5dbfff29bcca49d861a0e83-4cbbd.png 800w\\\"\\n        sizes=\\\"(max-width: 590px) 100vw, 590px\\\"\\n      />\\n    </span>\\n  </span>\\n  </p>\\n<p>primitive跟object的差別在於，primitive會在heap create一個新的，然後將新的ref傳出去，而object不會，只會將現有的ref傳出去。最後，js會自動分辨型別，決定拿到的ref是\\nprimitive還是object。</p>\\n<p>網路上也能找到這張圖</p>\\n<p>\\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block; ; max-width: 436px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 50.68807339449541%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsSAAALEgHS3X78AAABxElEQVQoz11S2XaiUBDk/7/FZ98SGaMzZjREjMriAmpYFBVwQ41ac6tznONJv9wLt6u6urq1PM9RFAW88Qi1eh2j0RjFocB+v8ftdgPj57ndbnE8nTCPQjw9V+D5Po7Hb4xWLpdRe3mBZTtYLBaIogir1UoRj5Bl2X+i6/Uq9+VyCb1SQa1aRb/fRxjFCIMAaZrKt+Y4Dna7HdbrNTabjVSn4tlsJmDG5XKR83A4oFQqYTAYCAEFEMf7+XxGr9eDVv2lw3GHQsYHqqL0yWQigHvwv+u6oEXdbhe2ban3RHL5j0VbrRY0PrIKWyUBVTHBV77M53MhS5JEEdhyZzcDRczcIPhEHMeSR/XNZhPa39dXWFZf+s/zDU7K7MvXlyRSNcnY4j1oSffjQw1xDNuykGZqqIqMPrOoZhiGgKfTKTzPE2WfymS2Z5od8fJxwixC3+M4QhCG0hnx7KrT6UBrNBoCdgcuHFXBsmzlqQvj3RDgnexxZUzTxFhtQZpmal2O4iNjOBx+K6QHVMhKbJEDoNLHtXlUSAvoNdURSz9ZqN1uQ9N1He+K1PcnknxfBe4hyX8Scih/ftfx9mYgUaQkYh5PTvkfILboBpMHtuEAAAAASUVORK5CYII='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"stack_n_heap2.png\\\"\\n        title=\\\"\\\"\\n        src=\\\"/static/stack_n_heap2-e43d40986d2db92e23897b29c69e1700-704f6.png\\\"\\n        srcset=\\\"/static/stack_n_heap2-e43d40986d2db92e23897b29c69e1700-e054b.png 148w,\\n/static/stack_n_heap2-e43d40986d2db92e23897b29c69e1700-1e7c4.png 295w,\\n/static/stack_n_heap2-e43d40986d2db92e23897b29c69e1700-704f6.png 436w\\\"\\n        sizes=\\\"(max-width: 436px) 100vw, 436px\\\"\\n      />\\n    </span>\\n  </span>\\n  </p>\\n<p>primitive是直接存在stack裡面的，也是網路上比較多的文章寫的，我認為就是看環境complier的實作方式。</p>\\n<p>由於這張圖，有人說js只能call by value的，只是傳出去的時候，primitive的value是實際的值，而object的\\bvalue的addr。</p>\\n<p><a href=\\\"https://stackoverflow.com/questions/33125547/javascript-string-stored-on-stack\\\">這篇</a>寫的很好</p>\\n<blockquote>\\n<p>In any case, for the JS programmer, worrying about stacks and heaps is somewhere between meaningless and distracting. It's more important to understand the behavior of various types of values.</p>\\n</blockquote>\\n<p>我認為primitive存在哪裡並不是這麼重要(但primitive與object的比較還有heap memory還是很重要)。然後我個人偏好第一種說法，因為stack的size應為fixed，才有使用stack的優點。</p>\\n<h4>stack &#x26; heap 比較</h4>\\n<table>\\n<thead>\\n<tr>\\n<th>Stack</th>\\n<th>Heap</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>在compile時期知道size</td>\\n<td>在runtime分配size</td>\\n</tr>\\n<tr>\\n<td>FILO(跟function exec順序有關)</td>\\n<td>沒有特別順序</td>\\n</tr>\\n<tr>\\n<td>靜態分配</td>\\n<td>動態分配</td>\\n</tr>\\n</tbody>\\n</table>\\n<h3>memory leak issue</h3>\\n<p>在以前沒有es6與module(common js require)之前，常常用clousre保存變數。那時候是dom的操作，加上瀏覽器引擎沒這麼好，電腦沒這麼強，對於memory要求比較care。現在的話使用eco-system寫好的framework，加上原生的module功能，很少人會特別說到memory的問題，不過對於SPA來說，使用者瀏覽的時間偏長(更正確應該說SPA所有操作都是在同一頁面的javascript)，如果這頁面是面對眾多的user還是需要注意。</p>\\n<p>javascript是動態語言會自己分配memory，同樣的也有自己的GC機制。</p>\\n<p>最簡單的GC演算法，會偵測變數是否有被其他人引用，若是沒有就會進行memory回收。</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code class=\\\"language-js\\\"><span class=\\\"token keyword\\\">var</span> obj1 <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">{</span>\\n  obj2<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token punctuation\\\">{</span><span class=\\\"token punctuation\\\">}</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n<span class=\\\"token comment\\\">// 2 objs create</span>\\n\\n<span class=\\\"token keyword\\\">var</span> obj3 <span class=\\\"token operator\\\">=</span> obj1<span class=\\\"token punctuation\\\">;</span> <span class=\\\"token comment\\\">// obj1 got 2 ref(itself &amp; obj3)</span>\\n\\n<span class=\\\"token keyword\\\">var</span> obj1 <span class=\\\"token operator\\\">=</span> <span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">;</span> <span class=\\\"token comment\\\">// obj1 got 1 ref(obj3)</span>\\n\\n<span class=\\\"token keyword\\\">var</span> obj4 <span class=\\\"token operator\\\">=</span> obj3<span class=\\\"token punctuation\\\">.</span>obj2 <span class=\\\"token comment\\\">// obj2 got 2 ref(obj3's property &amp; obj4)</span>\\n\\nobj3 <span class=\\\"token operator\\\">=</span> <span class=\\\"token number\\\">456</span><span class=\\\"token punctuation\\\">;</span> <span class=\\\"token comment\\\">// no one need obj1, obj1 got GCed</span>\\n\\nobj4 <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">null</span> <span class=\\\"token comment\\\">// no one need obj2, obj2 got GCed</span></code></pre>\\n      </div>\\n<p>但這無法解決cycle ref</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code class=\\\"language-js\\\"><span class=\\\"token keyword\\\">function</span> <span class=\\\"token function\\\">f</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token keyword\\\">var</span> o1 <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">{</span><span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">;</span>\\n  <span class=\\\"token keyword\\\">var</span> o2 <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">{</span><span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">;</span>\\n  o1<span class=\\\"token punctuation\\\">.</span>p <span class=\\\"token operator\\\">=</span> o2<span class=\\\"token punctuation\\\">;</span> <span class=\\\"token comment\\\">// o1 references o2</span>\\n  o2<span class=\\\"token punctuation\\\">.</span>p <span class=\\\"token operator\\\">=</span> o1<span class=\\\"token punctuation\\\">;</span> <span class=\\\"token comment\\\">// o2 references o1. This creates a cycle.</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n\\n<span class=\\\"token function\\\">f</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span></code></pre>\\n      </div>\\n<p>所以後來GC機制改用Mark-and-sweep演算法，簡言之從global當作root，往chilren一步一步走，將走過的變數設為active。最後將非active的變數釋放掉。</p>\\n<p>所以不管有沒有cycle循環，只要root抵達不了就會回收。2012的時候，大部份的modern browser更新了此GC。</p>\\n<p>雖說了這麼多，但還是有四個常見的JS memory leak</p>\\n<h4>global variable</h4>\\n<p>大家都是知道少用global var，且在global = root情況下是不會回收的，比較常見的是</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code class=\\\"language-js\\\"><span class=\\\"token keyword\\\">function</span> <span class=\\\"token function\\\">foo</span><span class=\\\"token punctuation\\\">(</span>arg<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    bar <span class=\\\"token operator\\\">=</span> <span class=\\\"token string\\\">\\\"some text\\\"</span><span class=\\\"token punctuation\\\">;</span> <span class=\\\"token comment\\\">// oops</span>\\n<span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>另外適時的使用global var是好的，不過當不用的時候可以ressign it或是 delete property。</p>\\n<h4>timer &#x26; callback</h4>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code class=\\\"language-js\\\"><span class=\\\"token keyword\\\">var</span> data <span class=\\\"token operator\\\">=</span> <span class=\\\"token string\\\">'123'</span><span class=\\\"token punctuation\\\">;</span>\\n\\n<span class=\\\"token function\\\">setInterval</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">function</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token keyword\\\">var</span> dom <span class=\\\"token operator\\\">=</span> document<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">getElementById</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'test'</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n  test<span class=\\\"token punctuation\\\">.</span>innerHtml <span class=\\\"token operator\\\">=</span> data<span class=\\\"token punctuation\\\">;</span>\\n  <span class=\\\"token comment\\\">// might be better</span>\\n  <span class=\\\"token comment\\\">// document.getElementById('test').innerHtml = data;</span>\\n<span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">,</span><span class=\\\"token number\\\">1000</span><span class=\\\"token punctuation\\\">)</span>\\n\\n<span class=\\\"token comment\\\">// data never GCed</span></code></pre>\\n      </div>\\n<p>由於dom有可能從頁面上消失掉，所以包在function裡面是很多餘的</p>\\n<p>另外data被Interval event使用著，所以never GCed</p>\\n<p>上面的better寫法除了說減少多餘以外，另外因為不用宣告var，memory上略好一點</p>\\n<p>不過code的<a href=\\\"https://stackoverflow.com/questions/8766220/javascript-declaring-variables-or-not\\\">可讀性</a>更重要，我覺得最重要的應該是data不能被GC</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code class=\\\"language-js\\\"><span class=\\\"token keyword\\\">var</span> button<span class=\\\"token operator\\\">=</span> document<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">getElementById</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'button'</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\nbutton<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">addEventListener</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'click'</span><span class=\\\"token punctuation\\\">,</span> onClick<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token comment\\\">//remove yourself if not need</span>\\nbutton<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">removeEventListener</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'click'</span><span class=\\\"token punctuation\\\">,</span> onClick<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span></code></pre>\\n      </div>\\n<p>但聽說現在modern的瀏覽器都會幫忙檢查observer相關的問題了</p>\\n<p>以前都需要自己寫removeListener before remove dom現在就不用囉(但寫了才是有quality的code，而且還是會有非modern browser的使用者)</p>\\n<h4>額外的dom參考</h4>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code class=\\\"language-js\\\"><span class=\\\"token keyword\\\">var</span> elements <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">{</span>\\n    button<span class=\\\"token punctuation\\\">:</span> document<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">getElementById</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'button'</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">,</span>\\n    image<span class=\\\"token punctuation\\\">:</span> document<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">getElementById</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'image'</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">,</span>\\n    text<span class=\\\"token punctuation\\\">:</span> document<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">getElementById</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'text'</span><span class=\\\"token punctuation\\\">)</span>\\n<span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">;</span>\\n\\n<span class=\\\"token keyword\\\">function</span> <span class=\\\"token function\\\">doStuff</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    image<span class=\\\"token punctuation\\\">.</span>src <span class=\\\"token operator\\\">=</span> <span class=\\\"token string\\\">'http://some.url/image'</span><span class=\\\"token punctuation\\\">;</span>\\n    button<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">click</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    console<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span>text<span class=\\\"token punctuation\\\">.</span>innerHTML<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token comment\\\">// Much more logic</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n\\n<span class=\\\"token keyword\\\">function</span> <span class=\\\"token function\\\">removeButton</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token comment\\\">// The button is a direct child of body.</span>\\n    document<span class=\\\"token punctuation\\\">.</span>body<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">removeChild</span><span class=\\\"token punctuation\\\">(</span>document<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">getElementById</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'button'</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n\\n    <span class=\\\"token comment\\\">// At this point, we still have a reference to #button in the global</span>\\n    <span class=\\\"token comment\\\">// elements dictionary. In other words, the button element is still in</span>\\n    <span class=\\\"token comment\\\">// memory and cannot be collected by the GC.</span>\\n<span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>有時候因為方便，會在js裡面寫hash map，對於dom如同有兩個ref(one from dom tree, one from js)。</p>\\n<p>如果你只從dom tree刪除，因為還有js的ref，所以memory無法GC</p>\\n<p>特別的是如果你對一個td做記憶，然後移掉整個table，最後整個table無法被GC(因為必須同時記得他的parent)</p>\\n<p>已經很少對於dom進行直接操作，不過想想以前好像寫過許多這種ng行為XD</p>\\n<h4>Closure</h4>\\n<p>實務上可能每天都在用closure，也有一些很tricky的行為</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code class=\\\"language-js\\\"><span class=\\\"token keyword\\\">var</span> theThing <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">null</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token keyword\\\">var</span> <span class=\\\"token function-variable function\\\">replaceThing</span> <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">function</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token keyword\\\">var</span> originalThing <span class=\\\"token operator\\\">=</span> theThing<span class=\\\"token punctuation\\\">;</span>\\n  <span class=\\\"token keyword\\\">var</span> <span class=\\\"token function-variable function\\\">unused</span> <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">function</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>originalThing<span class=\\\"token punctuation\\\">)</span>\\n      console<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"hi\\\"</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n  <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">;</span>\\n  theThing <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">{</span>\\n    longStr<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">Array</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token number\\\">1000000</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">join</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'*'</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">,</span>\\n    someMethod<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token keyword\\\">function</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n      console<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span>someMessage<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token punctuation\\\">}</span>\\n  <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token function\\\">setInterval</span><span class=\\\"token punctuation\\\">(</span>replaceThing<span class=\\\"token punctuation\\\">,</span> <span class=\\\"token number\\\">1000</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span></code></pre>\\n      </div>\\n<p>網路的文章我看了很久，我不確定我的說法是不是對的</p>\\n<p>因為theThing在replaceThing裡面被引用了，而someMethod是一個closure，其中的一個free variable是unused，但因為unused也是closures，然後同樣parent scope中的closures會互相shared scope。在這個unused裡面又用到了originalThing(引用了上個循環的thingThing)，所以造成這個\\\"上一次\\\"的theThing也需要被記憶不能被GC。</p>\\n<p>我將unused移除，並且用chrome dev tool查看，確實有unused會memory leak，沒有的就不會。</p>\\n<p>其實任何的function在建立時皆為一個closure，並不是function retrun function才是closure。有些定義是需要有free variables才算closure。</p>\\n<p>但由上面的整理也得知，就算closure裡面有許多的var，只要沒有被引用，就不會有memory的問題啦(不過無用的var eslint應該會警告)</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code class=\\\"language-js\\\"><span class=\\\"token comment\\\">// y沒用到會自己被回收，x就會一直保存</span>\\n\\b<span class=\\\"token keyword\\\">const</span> <span class=\\\"token function-variable function\\\">test</span> <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">(</span>x<span class=\\\"token punctuation\\\">,</span>y<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">=></span> z <span class=\\\"token operator\\\">=></span> x <span class=\\\"token operator\\\">+</span> z<span class=\\\"token punctuation\\\">;</span></code></pre>\\n      </div>\\n<p>實際喔，我覺得還是memory detect in action吧 XD，畢竟js這麼神奇。重點是當你從工具中察覺到了memory leak的時候，是否能歸納出是哪種問題。</p>\\n<br>\\n<p>memory可以參考<a href=\\\"https://segmentfault.com/a/1190000007536949\\\">此</a></p>\\n<p>memory leak可以參考<a href=\\\"https://auth0.com/blog/four-types-of-leaks-in-your-javascript-code-and-how-to-get-rid-of-them/\\\">此</a></p>\"}},{\"node\":{\"fields\":{\"slug\":\"/posts/javascript-context/\"},\"frontmatter\":{\"title\":\"Javascript context & execution context\",\"date\":\"2018-03-25T19:49\",\"tags\":[\"mechanic\"],\"release\":true},\"html\":\"<snippet>\\n  這邊試著整理一些javscript的context概念(教練我原本只想寫event loop啊，越寫越多orz...)\\n</snippet>\\n<p>先說說js function，在w3c的\\b<a href=\\\"https://www.w3schools.com/js/js_function_invocation.asp\\\">定義</a>中，呼叫一個function稱為invoke。</p>\\n<p>在看js文章與執行function的時候當會看到一個字 - 執行環境(Execution Context)</p>\\n<p>Execution Context就是執行javascript時候的環境(有講跟沒講一樣XD)，更準確的來說，上下文環境，確認執行時候的this, var, method...</p>\\n<p>Execution Context有三種</p>\\n<ol>\\n<li>Gobal Execution Context - 一開始的地方，browser來說就是window</li>\\n<li>Functional Execution Context - 執行function的地方</li>\\n<li>Eval - 不常用</li>\\n</ol>\\n<p>當js invoke一個function時，會從global開始呼叫function，並且建立execution context，如果有很多function，就會一層疊一層的，此稱為execution context stack，而我們執行function的方式稱之為call stack。</p>\\n<p>js建立execution context有兩個步驟</p>\\n<ol>\\n<li>建立階段</li>\\n<li>執行階段</li>\\n</ol>\\n<h4>建立階段</h4>\\n<ol>\\n<li>建立activation object or the variable object\\nvariable object指的是存放execution context scope data的物件，是一個抽象的概念，在不同的\\bcontext裡面實作方式(存放的東西)是不一樣的。\\n在global context中的variable object等同於自己，並且可以直接對變數引用，所以你能向下面一樣呼叫</li>\\n</ol>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code class=\\\"language-js\\\"><span class=\\\"token keyword\\\">var</span> a <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">String</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'test'</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n\\n<span class=\\\"token function\\\">alert</span><span class=\\\"token punctuation\\\">(</span>a<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span> <span class=\\\"token comment\\\">// directly, is found in VO(globalContext): \\\"test\\\"</span>\\n\\n<span class=\\\"token function\\\">alert</span><span class=\\\"token punctuation\\\">(</span>window<span class=\\\"token punctuation\\\">[</span><span class=\\\"token string\\\">'a'</span><span class=\\\"token punctuation\\\">]</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span> <span class=\\\"token comment\\\">// indirectly via global === VO(globalContext): \\\"test\\\"</span>\\n<span class=\\\"token function\\\">alert</span><span class=\\\"token punctuation\\\">(</span>a <span class=\\\"token operator\\\">===</span> <span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span>a<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span> <span class=\\\"token comment\\\">// true</span></code></pre>\\n      </div>\\n<p>在function \\bcontext中的VO稱之activation object，不能直接被引用，裡面要放入function arguments，context的var與function定義。</p>\\n<ul>\\n<li>\\n<p>對於每一個var，js會幫AO create一個property with value undefined，如果存在property就略過。</p>\\n</li>\\n<li>\\n<p>建立property for arg，把arguments object丟進去(reference)</p>\\n</li>\\n<li>\\n<p>對於function，js會create一個function，然後create property by function name，然後將ref丟進去，如果存在property就覆蓋。</p>\\n</li>\\n<li>\\n<p>建立scope chain\\n想像成一個array或是list，將裡面塞入VO(包涵現在所在的) [bFunc VO, a FuncVO, Global VO]\\n(es5會產生global scope, function scope，es6 let會產生block scope)</p>\\n</li>\\n<li>\\n<p>確認this的指向。</p>\\n</li>\\n</ul>\\n<p>最後</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code class=\\\"language-js\\\">executionContextObj <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">{</span>\\n    scopeChain<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token punctuation\\\">{</span> <span class=\\\"token comment\\\">/* variableObject + all parent execution context's variableObject */</span> <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">,</span>\\n    variableObject<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token punctuation\\\">{</span> <span class=\\\"token comment\\\">/* function arguments / parameters, inner variable and function declarations */</span> <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">,</span>\\n    <span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">:</span> <span class=\\\"token punctuation\\\">{</span><span class=\\\"token punctuation\\\">}</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n\\n<span class=\\\"token comment\\\">// example</span>\\nFuncExecutionContextObj <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">{</span>\\n  activationbj<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token punctuation\\\">{</span>\\n      argumentObj <span class=\\\"token punctuation\\\">:</span> <span class=\\\"token punctuation\\\">{</span>\\n          <span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">:</span> e<span class=\\\"token punctuation\\\">,</span>\\n          length<span class=\\\"token punctuation\\\">:</span><span class=\\\"token number\\\">1</span>\\n      <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">,</span>\\n      a<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token number\\\">10</span><span class=\\\"token punctuation\\\">,</span>\\n      b<span class=\\\"token punctuation\\\">:</span> undefined<span class=\\\"token punctuation\\\">,</span>\\n      c<span class=\\\"token punctuation\\\">:</span> undefined\\n      Func<span class=\\\"token punctuation\\\">:</span> Pointer to the Function definition<span class=\\\"token punctuation\\\">,</span>\\n  <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">,</span>\\n  scopeChain<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token punctuation\\\">[</span>Func variable object<span class=\\\"token punctuation\\\">,</span> Global exection context variable object<span class=\\\"token punctuation\\\">]</span><span class=\\\"token punctuation\\\">,</span>\\n  <span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">:</span> value <span class=\\\"token keyword\\\">of</span> <span class=\\\"token keyword\\\">this</span>\\n<span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<h4>執行階段</h4>\\n<p>從上逐步執行每一行code，若是跑到變數宣告才會賦值。</p>\\n<p>不過這樣很容易解釋</p>\\n<ol>\\n<li>var hoisting，因為create stage就已經知道變數了</li>\\n<li>var hoisting但呼叫var時為undefined，因為實際給值的動作可能在呼叫之後</li>\\n<li>function hoisting但能呼叫，因為function的處理方式是不一樣的</li>\\n<li>function expression與function declaration是不一樣的，function declaration視為var 宣告，在執行階段跑到變數宣告才會create function</li>\\n</ol>\\n<p>寫完文章才理解大家常常在說的上下文是\\\"context\\\"(翻了中英對照才知道...)，實作中比較常會遇到this的指向問題，這邊並沒有多做著磨，我們應該少使用一些反模式就可以大幅減少遇到問題的可能性，像多用es6 module與arrow function就是一種好的寫法(大部份的function不用dynamic this對吧)，有一些this太刁鑽了，想要的看<a href=\\\"https://halfrost.com/javascript_this/\\\">這裡</a>。</p>\\n<h4>後記</h4>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code class=\\\"language-js\\\"><span class=\\\"token keyword\\\">var</span> a <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token function\\\">b</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">const</span> c <span class=\\\"token operator\\\">=</span> <span class=\\\"token string\\\">'12'</span><span class=\\\"token punctuation\\\">;</span>\\n    console<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token keyword\\\">function</span> <span class=\\\"token function\\\">d</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n      console<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span>c<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n      console<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token punctuation\\\">}</span>\\n    <span class=\\\"token function\\\">d</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n  <span class=\\\"token punctuation\\\">}</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n\\na<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">b</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n\\n<span class=\\\"token comment\\\">// {b: ƒ}</span>\\n<span class=\\\"token comment\\\">// 12</span>\\n<span class=\\\"token comment\\\">// Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, frames: Window, …}</span></code></pre>\\n      </div>\\n<p>\\bthis的指向是跟著context的，而讀取變數是跟著scope的，上面範例，在執行d的時候，實際執行者是window，但變數是跟著scope chain所以能讀到c = 12。我發現之前我理解錯誤，我把\\bcontext與execution context連想在一起，但在javascript這兩個詞應該是不一樣的(好模糊啊)，execution context是scope VO加上\\\"context\\\"指向的this，所以我認為d是由b執行的，所以該指向execution context的this，但execution context實際上並沒有this的值，只有確認this的綁定。以d()來說，invoke一個unbounded function，其context指向global(\\bglobal.d())，而execution context把global存起來，再想到callback形式的寫法( arr.map(function(){ }) )，就能得知其實是一樣的道理。</p>\\n<h4>Context vs. Scope</h4>\\n<blockquote>\\n<p>The first important thing to clear up is that context and scope are not the same. I have noticed many developers over the years often confuse the two terms (myself included), incorrectly describing one for the other. To be fair, the terminology has become quite muddled over the years.</p>\\n</blockquote>\\n<blockquote>\\n<p>Every function invocation has both a scope and a context associated with it. Fundamentally, scope is function-based while context is object-based. In other words, scope pertains to the variable access of a function when it is invoked and is unique to each invocation. Context is always the value of the this keyword which is a reference to the object that “owns” the currently executing code.</p>\\n</blockquote>\"}},{\"node\":{\"fields\":{\"slug\":\"/posts/browser-mechanic/\"},\"frontmatter\":{\"title\":\"Browser render & performance\",\"date\":\"2018-03-25T15:29\",\"tags\":[\"mechanic\",\"performance tuning\"],\"release\":true},\"html\":\"<snippet>\\n  原本要介紹javascript event loop的，寫一寫變成介紹browserXDD\\n</snippet>\\n<p>有人問在處理器\\bloading js會block render是為什麼，我知道js是single thread，但並不能確定是single thread的問題，於是乎一切要從browser講起。</p>\\n<p>modern browser通常是multi process的，自己認為最大的優點是</p>\\n<ul>\\n<li>避免一頁crash而導致整個browser crash</li>\\n<li>避免插件crash而導致整個browser crash</li>\\n</ul>\\n<p>而對於前端最重要的就是渲染進程(process)，而一個process又可以分成multi thread，而渲染進程裡面擁有的重要thread</p>\\n<ul>\\n<li>GUI</li>\\n<li>JS</li>\\n<li>Event</li>\\n<li>Timer</li>\\n<li>Http request</li>\\n</ul>\\n<p>GUI與JS \\bthread是戶斥的，因為當repaint的時候會觸發GUI \\bthread，但JS執行後很有可能會造成多次repaint，於是乎JS在執行的時候會先block GUI thread，待JS結束後才換GUI thread。</p>\\n<p>所以如果在browser裡需要做密集運算可以使用web worker，browser會開一個子thread用來處理運算，但是不能操作dom，這是一個很酷的功能，目前的專案有地方可以優化的，只是browser的支援度還不夠所以放棄(IE 11 up...)，希望未來有機會玩囉。</p>\\n<p>假設我們發送了一個http request，browser的行為大致如下</p>\\n<ol>\\n<li>Get content from http request</li>\\n<li>Parse html and create dom tree (trigger DOMContentLoaded)</li>\\n<li>Parse css and create render tree(with dom tree)</li>\\n<li>(Layout/Reflow) the render tree</li>\\n<li>Paint the render tree</li>\\n<li>Composite &#x26; show on screen (trigger load)</li>\\n</ol>\\n<p>\\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block; ; max-width: 590px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 48.701298701298704%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABYlAAAWJQFJUiTwAAAB6UlEQVQoz11SXW+bMBTNz9/jtP2Bve1h+wd7qKpulaZoSqONkLZAIBAgJkAwBgM2nF3cJWp3pKvra1+f+7kAoSgqdLKZj+gahor9wjj2xh5HbXR1Lskvp9OEKyZt7GkajcxYiOIPTukG7QDMzyf2DG/1Hn0nrv8GevCCBJ4foeqAutiijO8M9fiaf5qwODx9Rex8Qcs9SBEhi27BCweKArZSgLOflD2HkCPqVlPwNfncIWcWWHiDlioqku9Qjf+SYcsDiCqA49pIEhcH6wNOeQo/bsCOLoKHd6jPIRJWYReVSPY/wJxPyMsC69U3hHGMrb3Ek/NoKlmYPpHUEjgwActawt3tUNQaspPom9BoP8oQkDgBw2azxHNwxDHvUPABrJCIGYfSVHLfddCKGkhN5ULidJakezI1Rq2Mk1KKhjOaAaUsxy7MkJ+FGYrWA90r4296ODsyxhBT6j1lMqNuFI5ZhZyPZlgsy9F1Pd6CAmn9L9CLGML5ac5Ak8hBwUtDrJ5s+MczCmbTNG+IrDX94ac1RHb/ZnP+x2JmvWAmtIJH2CROzLEPfiPa3WKf5JAKyLzPSO2PKBsJN/bhJgH9Ga4rYzK8HF4TzxBNj5IaXtPepaykjxM67kCWGzAu8OBZ2EYBOqrsQjjjL3B7+wLRL+N4AAAAAElFTkSuQmCC'); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"RenderTree\\\"\\n        title=\\\"\\\"\\n        src=\\\"/static/RenderTree-7efd7b826a452eb48175a6d2846a6b1f-a408b.png\\\"\\n        srcset=\\\"/static/RenderTree-7efd7b826a452eb48175a6d2846a6b1f-4eabf.png 148w,\\n/static/RenderTree-7efd7b826a452eb48175a6d2846a6b1f-5a375.png 295w,\\n/static/RenderTree-7efd7b826a452eb48175a6d2846a6b1f-a408b.png 590w,\\n/static/RenderTree-7efd7b826a452eb48175a6d2846a6b1f-9a0cc.png 885w,\\n/static/RenderTree-7efd7b826a452eb48175a6d2846a6b1f-aa987.png 1180w,\\n/static/RenderTree-7efd7b826a452eb48175a6d2846a6b1f-c00d7.png 1540w\\\"\\n        sizes=\\\"(max-width: 590px) 100vw, 590px\\\"\\n      />\\n    </span>\\n  </span>\\n  </p>\\n<p>原本我知道javascript要放在body之後或是寫上defer，這邊我才發現css也會block render(dom tree ok，但render tree不行)，但是為了first time render，所以css一定要放在head，但如果很大要進行特殊處理，這邊有另一個領域叫critical render path(因為main css屬於critical但\\bjs不是，所以js可以慢load)。</p>\\n<p>(這就非常有趣了，首先我不知道webpack包裝成的SPA是怎麼處理css的，另外就是css in jsx，loader，styled-Component各會造成怎樣的效果。之後研究的目標之一)</p>\\n<p>composite是另一個很有趣的概念，首先要先了解render pipeline</p>\\n<p>\\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block; ; max-width: 590px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 10.91160220994475%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAYAAABYBvyLAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAm0lEQVQI1yXMTwvBYADAYV/SyUXtMAelltZIS2YbRpJ8ArZx22VZmLO/RydHpU2U9xP8LDs9t6cgzmXEWUJcK4iLxPckEczueMM3npOwGqe4gwTfeeFPHliRjhmrGNs69r7519yp2HGD1rpKQRxLeXSR8/hQJJjecJ0Pi16SZXm4HKXM+0+6oY4RK+hRjU6WtTcKVqxlYRMtlPkB1Q51jFyu9xUAAAAASUVORK5CYII='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"render_pipeline\\\"\\n        title=\\\"\\\"\\n        src=\\\"/static/render_pipeline-18578f2ae7d686d16ac1ea1bc606f83c-a408b.png\\\"\\n        srcset=\\\"/static/render_pipeline-18578f2ae7d686d16ac1ea1bc606f83c-4eabf.png 148w,\\n/static/render_pipeline-18578f2ae7d686d16ac1ea1bc606f83c-5a375.png 295w,\\n/static/render_pipeline-18578f2ae7d686d16ac1ea1bc606f83c-a408b.png 590w,\\n/static/render_pipeline-18578f2ae7d686d16ac1ea1bc606f83c-9a0cc.png 885w,\\n/static/render_pipeline-18578f2ae7d686d16ac1ea1bc606f83c-aa987.png 1180w,\\n/static/render_pipeline-18578f2ae7d686d16ac1ea1bc606f83c-52bff.png 1448w\\\"\\n        sizes=\\\"(max-width: 590px) 100vw, 590px\\\"\\n      />\\n    </span>\\n  </span>\\n  </p>\\n<p>在前端的渲染機制是這樣</p>\\n<ul>\\n<li>Javascript - trigger event</li>\\n<li>Style - css selector</li>\\n<li>Layout - calculate Layout</li>\\n<li>Paint - fill pixel</li>\\n<li>Composite - layer merge</li>\\n</ul>\\n<p>只介紹後面三個，跟頁面排版有關的東西會重新計算(width, height, left...)，此種行為觸發layout，跟繪制有關的觸發paint(color, border...)，跟layer有關的觸發composite，這是一個pipeline，但不是每一個都要經過，經過越少step的效能越好。而通常在一個沒有特別設置的頁面只會有一個layer(或是browser預設的layer?待求證)，但我們可以用tranform, translate 3d, will-change等去特別制造一個layer出來，最後composite的時候就會組合起來。所以就以純移動來講，使用tranform(\\bStyle -> Composite)比left(\\bStyle -> Layout -> Paint -> Composite)好，但實際使用一個頁面太多layer反而會降低效率，所以這又很吃應用場景。</p>\\n<p>當你修改了某些css的style，會產生不同的cost。這邊有份<a href=\\\"https://www.slideshare.net/ApoorvSaxena/performance-beyond-page-load\\\">簡報</a>，甚至你可以到<a href=\\\"https://csstriggers.com/\\\">css trigger</a>查詢。</p>\\n<p>(這邊也非常有趣，沒有實際優化過，不過用過一兩次will-change)</p>\\n<p>PS. 其實大部份的概念來自<a href=\\\"http://www.dailichun.com/2018/01/21/js_singlethread_eventloop.html\\\">這篇文章</a>，建議好好的看過文章，因為我的版本省略了很多介紹XD</p>\\n<p>不過以上介紹的東西在現代的前端開發(SPA component...)還需要再釐清，很多都是3-4年前的推廣，像是css建議多用class而不要js控制，但jsx推崇css in js，另外在render部份使用vdom技術，加上使用webpack打包會不會已經不用關注某些問題值得再討論。</p>\"}},{\"node\":{\"fields\":{\"slug\":\"/posts/new-year-wish/\"},\"frontmatter\":{\"title\":\"New Year Wish\",\"date\":\"2018-02-20T18:06\",\"tags\":[\"nothing special\"],\"release\":true},\"html\":\"<snippet>\\n  新年到了，該給自己一個目標。\\n</snippet>\\n<p>原本是想要每個月寫一篇文章的，但是人都有惰性(\\bx)。</p>\\n<p>最近也在凖備轉職，從面試中也得知了許多自己的不足，雖然我知道這些問題可能都是拿來壓薪水的XD</p>\\n<p>近期也幫了公司導入unit test，因為要做教育訓練，也花了時間做投影片。從那些似曾相似的題目，從為了教育訓練而認真研究，能了解到一件事情。會用跟知道原理完全是兩回事，很多時候就覺得就是這樣，但說不出個所以然，感覺就很javavscript，因為javascript就是一個這麼不嚴格的語言XD</p>\\n<p>import module用慣了，套件用久了，react寫多了，這麼的declative，反而造成了只知道怎麼用，而不知道原因。目前短期先把javascript的重要概念先補完吧，同時想要解決兩件事情，第一，當有人問起時，可以完整的告知原因，而不是隨便呼嚨兩句，第二，也是我最一開始的理想，把那些常忘記的事情記錄，會常忘記就是因為每次都好像是這樣，大概是這樣。</p>\\n<p>這次增加了一頁TODO LIST，不記錄一下，我連想寫什麼文章都要忘了。</p>\\n<p>原本的夢想是成為一個優秀的前端工程師，開著chrome dev tools，為使用者的0.01秒而奮鬥，但是在台灣的工作中好像沒有看過，大部份都是開發速度導向，當然我開發上也還有進步的空間，不過今年看到印象最深刻的還是react 0.16頁面中的<a href=\\\"https://medium.com/@paularmstrong/twitter-lite-and-high-performance-react-progressive-web-apps-at-scale-d28a00e780a3\\\">twitter PWA tunning</a>。</p>\\n<p>當然新年還是要玩一些新東西，還在想要朝向isomorphic還是react-native邁進。react-native比起以前已經相對的成熟了，通常做app更講究使用者體驗，也是我更有興趣的一部份，但是fullstack在職涯上有絕對的優勢，自己寫過過往的full stack mvc，也改過公司後台的nodejs(refactor一些東西)，非常不認同前端是比較簡單的工作(薪水比較低)，只是注意的點是不一樣的，我更在意的是使用者會如何跟我的介面互動，這就好像設計不值錢這種謬論是一樣的。</p>\\n<p>最後，今年應該是兩個都會碰一下，不過主要玩isomorphic &#x26; backend相關技術，這與我幾年後的目標比較match，當然最終可以react-native + isomorphic，等到時候再說吧，前端技術，每18個月重來一次呢。</p>\"}}]}},\"pathContext\":{\"offset\":0,\"paginations\":6,\"total\":26}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/index.json\n// module id = 450\n// module chunks = 142629428675168"],"sourceRoot":""}
{"version":3,"sources":["webpack:///path---fetch-in-react-life-cycle-f904d1d25bc0dc18ee2f.js","webpack:///./.cache/json/fetch-in-react-life-cycle.json"],"names":["webpackJsonp","./node_modules/json-loader/index.js!./.cache/json/fetch-in-react-life-cycle.json","module","exports","data","site","siteMetadata","title","author","markdownRemark","id","html","frontmatter","date","tags","pathContext","slug"],"mappings":"AAAAA,cAAc,IAERC,mFACA,SAAUC,EAAQC,GCHxBD,EAAAC,SACAC,MACAC,MACAC,cACAC,MAAA,OACAC,OAAA,eAGAC,gBACAC,GAAA,iJACAC,KAAA,8tCACAC,aACAL,MAAA,0BACAM,KAAA,mBACAC,MACA,QACA,QACA,aACA,SAKAC,aACAC,KAAA","file":"path---fetch-in-react-life-cycle-f904d1d25bc0dc18ee2f.js","sourcesContent":["webpackJsonp([7],{\n\n/***/ \"./node_modules/json-loader/index.js!./.cache/json/fetch-in-react-life-cycle.json\":\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\n\t\t\"data\": {\n\t\t\t\"site\": {\n\t\t\t\t\"siteMetadata\": {\n\t\t\t\t\t\"title\": \"前端小誌\",\n\t\t\t\t\t\"author\": \"Ernie Yang\"\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"markdownRemark\": {\n\t\t\t\t\"id\": \"/Users/ernieyang09/Desktop/workspace/gatsby-blog/src/pages/posts/2017/07/0730--fetch-in-react-life-cycle.md absPath of file >>> MarkdownRemark\",\n\t\t\t\t\"html\": \"<snippet>\\n最近需要幫網站加入權限的機制，到底該怎們將權限加入React中\\n</snippet>\\n<p>由於公司是走oauth2.0，oauth2.0的官網在SPA推薦的是implicit flow，在npm也可以找到此部分的套件，但這不是這篇文章的重點，重點在於接完之後，該如何進行下一步驗證。</p>\\n<p>通常SPA要驗證一定會有一個flag或一組key，來做後續的動作，當然server端一定也要驗證，不然我前台亂輸入flag與key，資料就全部被弄出來了，以oauth來說我們就必須將accessToken當作前台的一個驗證。</p>\\n<p>這邊我的作法如下</p>\\n<p>確認是否有token -> request api取得個人資訊 -> 有了才登入 沒有就是假token</p>\\n<p>所以我們可以在首次render SPA的時候(也就是使用者第一次點開你的網頁的時候)進行request api的行為。</p>\\n<p>那到底要放在componentWillMount還是componentDidMount呢</p>\\n<h3>componentWillMount</h3>\\n<p>在Component Render之前就會執行，但是fetch資料屬於非同步，render並不會等待，此時還拿不到init state，有可能會出錯，必須自己在constructor先init state，<a href=\\\"https://daveceddia.com/watch-out-for-undefined-state/\\\">詳情見此</a>，會render兩次。</p>\\n<h3>componentDidMount</h3>\\n<p>就跟上面做了個對比，是比較建議放入ajax的地方，也會render兩次。</p>\\n<p>不過剛好最近出了v0.16，依照這篇<a href=\\\"https://www.reddit.com/r/reactjs/comments/5fg7iq/why_should_ajax_requests_go_in_componentdidmount/\\\">文章</a>來看，componentWillMount似乎是個好選擇(我還沒有驗證)</p>\\n<p>但其實React的Lifecycle是可以寫async await或是promise的，這邊就有很好的<a href=\\\"https://medium.com/front-end-hacking/async-await-with-react-lifecycle-methods-802e7760d802\\\">例子</a></p>\\n<p>在此情況下，我們可以在componentWillMount裡面await資料傳回來在繼續進行動作，經過測試後真的只會執行一次。</p>\\n<p>所以說拉，目前看起來在componentWillMount裡面等待應該是最好的方法。</p>\",\n\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\"title\": \"在React life cyle中做async\",\n\t\t\t\t\t\"date\": \"2017-07-30T21:15\",\n\t\t\t\t\t\"tags\": [\n\t\t\t\t\t\t\"react\",\n\t\t\t\t\t\t\"redux\",\n\t\t\t\t\t\t\"javascript\",\n\t\t\t\t\t\t\"前端\"\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\"pathContext\": {\n\t\t\t\"slug\": \"/fetch-in-react-life-cycle/\"\n\t\t}\n\t};\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---fetch-in-react-life-cycle-f904d1d25bc0dc18ee2f.js","module.exports = {\n\t\"data\": {\n\t\t\"site\": {\n\t\t\t\"siteMetadata\": {\n\t\t\t\t\"title\": \"前端小誌\",\n\t\t\t\t\"author\": \"Ernie Yang\"\n\t\t\t}\n\t\t},\n\t\t\"markdownRemark\": {\n\t\t\t\"id\": \"/Users/ernieyang09/Desktop/workspace/gatsby-blog/src/pages/posts/2017/07/0730--fetch-in-react-life-cycle.md absPath of file >>> MarkdownRemark\",\n\t\t\t\"html\": \"<snippet>\\n最近需要幫網站加入權限的機制，到底該怎們將權限加入React中\\n</snippet>\\n<p>由於公司是走oauth2.0，oauth2.0的官網在SPA推薦的是implicit flow，在npm也可以找到此部分的套件，但這不是這篇文章的重點，重點在於接完之後，該如何進行下一步驗證。</p>\\n<p>通常SPA要驗證一定會有一個flag或一組key，來做後續的動作，當然server端一定也要驗證，不然我前台亂輸入flag與key，資料就全部被弄出來了，以oauth來說我們就必須將accessToken當作前台的一個驗證。</p>\\n<p>這邊我的作法如下</p>\\n<p>確認是否有token -> request api取得個人資訊 -> 有了才登入 沒有就是假token</p>\\n<p>所以我們可以在首次render SPA的時候(也就是使用者第一次點開你的網頁的時候)進行request api的行為。</p>\\n<p>那到底要放在componentWillMount還是componentDidMount呢</p>\\n<h3>componentWillMount</h3>\\n<p>在Component Render之前就會執行，但是fetch資料屬於非同步，render並不會等待，此時還拿不到init state，有可能會出錯，必須自己在constructor先init state，<a href=\\\"https://daveceddia.com/watch-out-for-undefined-state/\\\">詳情見此</a>，會render兩次。</p>\\n<h3>componentDidMount</h3>\\n<p>就跟上面做了個對比，是比較建議放入ajax的地方，也會render兩次。</p>\\n<p>不過剛好最近出了v0.16，依照這篇<a href=\\\"https://www.reddit.com/r/reactjs/comments/5fg7iq/why_should_ajax_requests_go_in_componentdidmount/\\\">文章</a>來看，componentWillMount似乎是個好選擇(我還沒有驗證)</p>\\n<p>但其實React的Lifecycle是可以寫async await或是promise的，這邊就有很好的<a href=\\\"https://medium.com/front-end-hacking/async-await-with-react-lifecycle-methods-802e7760d802\\\">例子</a></p>\\n<p>在此情況下，我們可以在componentWillMount裡面await資料傳回來在繼續進行動作，經過測試後真的只會執行一次。</p>\\n<p>所以說拉，目前看起來在componentWillMount裡面等待應該是最好的方法。</p>\",\n\t\t\t\"frontmatter\": {\n\t\t\t\t\"title\": \"在React life cyle中做async\",\n\t\t\t\t\"date\": \"2017-07-30T21:15\",\n\t\t\t\t\"tags\": [\n\t\t\t\t\t\"react\",\n\t\t\t\t\t\"redux\",\n\t\t\t\t\t\"javascript\",\n\t\t\t\t\t\"前端\"\n\t\t\t\t]\n\t\t\t}\n\t\t}\n\t},\n\t\"pathContext\": {\n\t\t\"slug\": \"/fetch-in-react-life-cycle/\"\n\t}\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/fetch-in-react-life-cycle.json\n// module id = ./node_modules/json-loader/index.js!./.cache/json/fetch-in-react-life-cycle.json\n// module chunks = 7"],"sourceRoot":""}
webpackJsonp([0x81b8806e4260],{"./node_modules/json-loader/index.js!./.cache/json/index.json":function(n,s){n.exports={data:{allMarkdownRemark:{edges:[{node:{fields:{slug:"/posts/aws-s3-cdn-53/"},frontmatter:{title:"AWS簡略記",date:"2018-09-28T21:49",tags:["AWS"],release:!0},html:'<p><snippet>在公司做的頁面要上啦，說明要用AWS，跳坑研究一下(嗚嗚 需要devOps)，總共用了S3、CloudFront、Route53</snippet></p>\n<h3>S3 (Simple Storage Service)</h3>\n<p>雲端儲存，create一個bucket放置檔案，操作蠻簡單的。</p>\n<p>因為是要用來架站用，所有東西都要能被外界使用，所以要設立權限。這邊的權限是bucket裡面的object，而非bucket本身。\n\n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 590px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 72.6161369193154%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsSAAALEgHS3X78AAAB50lEQVQ4y62USU/bUBDH/Sm5gVBFeyugHiLU7cAiSlWJAIeeUCU+QA+tULkgAS00KrQJ0CK2xGv84iXBu+MQ+9/3bIrYAhR40l9vmfHPM/PG5pS6B8l04fg+olbrnIJmE14QwA/DW4srlLax+nMTa7+2sHqirxslHIoyLMeF62fAsqRgZb2Ib8y3uIXdioAwii4DB9++R3/+AwbGp/F0dAr9k7N4MjaD+eUCVFIDUVWEgY8vKwX0DVP7zBye5Wcx93E+zcLxvHPionaCqB2DzUmS4PO+jel1A/kfOia+ayjWArCR+WR+x3GCToNT7QiKxdSEH7XxrqAjt6jixRJBzycRC2UHTngMoRGm0twWWu1rgEQzQXQTmlFHtabDqB8hoLWI4xh3GZzjerAdD5ZNb5qumdianWW27JzV61bAR8/HIasEVSqiaRBlGbwg0IgNesP+jW1ysa243qExEMMEL4oo8zwFKvR2SQq0XfdG2CVgT240BbK6VYkKQZKxd3CA3392cFipwGw04Hdo7iuBj19NZED6VQiShGJpEzwvQKKR1nQdHk27SevHxMBHtn0a+ZXAvpdvoBAtdWKNyeZOtWMPM5t7Avq3987sue7cCHgaDXtzw7LuLa5r8HWa8v/8AK6t4UMD/wJEbmEEKFKajgAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"\n        alt="s3-1"\n        title=""\n        src="/static/970dab34abfe188cfe51567b5c6f38be-a408b.png"\n        srcset="/static/970dab34abfe188cfe51567b5c6f38be-4eabf.png 148w,\n/static/970dab34abfe188cfe51567b5c6f38be-5a375.png 295w,\n/static/970dab34abfe188cfe51567b5c6f38be-a408b.png 590w,\n/static/970dab34abfe188cfe51567b5c6f38be-24515.png 818w"\n        sizes="(max-width: 590px) 100vw, 590px"\n      />\n    </span>\n  </span>\n  </p>\n<p>可以使用AWS的policy generator即可。\n\n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 590px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 88.58195211786372%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAAAsSAAALEgHS3X78AAAB8ElEQVQ4y5VUXY/aMBDMv25/RV/bh74cFflwHDsJf6CtrlKPqOiokHovqGppQkKQjgJCQgKmu84FHZejFyKNZrWOx7u2x5bv++h2u3BsB7ZtQwgfWuuzUDpCoELDSoeNcUtJASk8CMeBcF0Ij2Ih4Utl4IkAkljKAMLnnEYUxQ+IGrC4QsdxSdRFQOKB70EFAYJHUEodIYOQKtQVBxVXuYqtXq8HhpRUFYkLIYwIM+d41fqfNrBiRZOUj8h3CDYi6SCOwotETgTDMDy2xcxV1XHF6tgSt1i3zuN8CA3Bk0Qc49P1Da6TEb5+G+H7j5+4G6et8fHzl1NBXnU8HiPLMhR5gel0auI0TfFnMjFxWZY4HA7PIkmSJxUSWGS5XGKxWGA+nxP/xX6/x0sfC/b7fToUapNPtAYLrlYr3N8vDDO22217wacVFkVhBLI0MxXudju0+V4U5L1ar9cNQZ54kWCe52bPzm38OfAcIxiG7FOPTpidIYzgpWI1bm8HsLT24TodaOWSzQQmv39hNpsZcNvlvKS4NHE2zTErq7ikHO9x/R/fisGAro2xHSE0tnON4GazeRZ3yXuU2ejs+HA4rKxXW6m2m+e58NwP9EZ2IOnBeGzF/9muab0HuJ03uHr7Gp13r+A5V/QmavB9bfM4/AOTf8QyVpJ4BQAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"\n        alt="s3-2"\n        title=""\n        src="/static/822f2cc9c4f0bb8735dd56ff463f9b90-a408b.png"\n        srcset="/static/822f2cc9c4f0bb8735dd56ff463f9b90-4eabf.png 148w,\n/static/822f2cc9c4f0bb8735dd56ff463f9b90-5a375.png 295w,\n/static/822f2cc9c4f0bb8735dd56ff463f9b90-a408b.png 590w,\n/static/822f2cc9c4f0bb8735dd56ff463f9b90-9a0cc.png 885w,\n/static/822f2cc9c4f0bb8735dd56ff463f9b90-c03c5.png 1086w"\n        sizes="(max-width: 590px) 100vw, 590px"\n      />\n    </span>\n  </span>\n  </p>\n<p>但要特別注意一點，在產生的Resource後面要加上/*，不然會發生<a href="https://stackoverflow.com/questions/44228422/s3-bucket-action-doesnt-apply-to-any-resources">Action does not apply to any resource(s) in statement\b</a>。</p>\n<p>如果只是要架一個簡單的網站，到這邊配上Static website hosting就很夠了，使用c\bdn的話這邊不需要hosting。</p>\n<h3>CloudFront</h3>\n<p>AWS提供的cdn服務</p>\n<p>選擇web服務，Origin Domain Name選擇剛剛建立的S3 bucket，小設定不提，因為我要用cdn架站，再用Route53指過來，\nDefault Root Object要寫entry，每個人應該都是index.html。Compress Objects Automatically可以加速，記得打開。另外一個重要的點，\n跑SPA網站，網站的route是由前端控制，\bhosting可以由Error Pages設定。\n\n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 590px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 45.16880093131548%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAABYlAAAWJQFJUiTwAAAA6ElEQVQoz5WS62qEMBCFff/n84eIl4Bso4n3ouL1NGfAslu07Q4cx8TJ55khnu/7SJIEQRBIDsMQcRyD+9yr6xrvhKeUQpZlDhJBpQqJg6VpiiiKkOc59n1/S97zomka9H2PcRwxTZPkeZ6xLMu3tm2TWtZdAmmTLywchkHEYlMYfDweKIoCXdeJ2D6hDK4vW+aDzqqqksOcm9Za9q4cHMchB/nTW+Cn+0iYNVZy27YIVP7r8MuyvAcyCCHMmAK1c6d1Lq7XdX0RXf4LeLZsjEHj4GzbWiutneIYzhn+CfwZd9finOFdfAF3ELtJH2HdHAAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"\n        alt="cloudfront-1"\n        title=""\n        src="/static/c9d09870ac47be483a77c3a01239bd97-a408b.png"\n        srcset="/static/c9d09870ac47be483a77c3a01239bd97-4eabf.png 148w,\n/static/c9d09870ac47be483a77c3a01239bd97-5a375.png 295w,\n/static/c9d09870ac47be483a77c3a01239bd97-a408b.png 590w,\n/static/c9d09870ac47be483a77c3a01239bd97-9a0cc.png 885w,\n/static/c9d09870ac47be483a77c3a01239bd97-aa987.png 1180w,\n/static/c9d09870ac47be483a77c3a01239bd97-ecaf3.png 1718w"\n        sizes="(max-width: 590px) 100vw, 590px"\n      />\n    </span>\n  </span>\n  \n如此一來，如果有人直接打上路由，會被導到index並且正常的轉到該顯示的頁面。</p>\n<h3>Route53</h3>\n<p>AWS提供的dns控管服務</p>\n<p>如果CloudFront要串到這裡，Alternate Domain Names (CNAMEs)要先打上Route53即將要給的domain，這邊好像沒什麼特別要注意的。CloudFront那邊可以設定ipv6，\bipv4就選A然後選alias貼上CloudFront的網址(\bxxxxx.cloudfront.net)，有ipv6就AAAA也設定一下。不確定是不是CloudFront要Delpoyed才能生效(\bCloudFront每次進入in progess都要1x-2x分鐘)</p>\n<p>PS.</p>\n<p>還有遇到ssl問題啦(如果CloudFront走https又改domain)，結果custom ssl一直反白，Certificate只能用\b<a href="https://stackoverflow.com/questions/28609262/unable-to-select-custom-ssl-certificate-stored-in-aws-iam">美東</a>的啦</p>\n<p>呼，總算弄完了!!</p>'}},{node:{fields:{slug:"/posts/map_eventhandler/"},frontmatter:{title:"React with map中的eventhandler",date:"2018-09-27T22:49",tags:["react","javascript"],release:!0},html:'<p>這個問題好像不常遇到，但是今天被同事問到的時候還一時回答不出來。</p>\n<p>問題淺顯易懂，在map function裡面的params要何如何傳出來parent。</p>\n<p>一下就回答用callback啊，但是仔細想一想要怎麼傳哬，囧。</p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Parent</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>\n  <span class="token operator">...</span>\n  handleClick <span class="token operator">=</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    <span class="token comment" spellcheck="true">// what to do</span>\n    <span class="token operator">...</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token punctuation">(</span>\n      <span class="token operator">&lt;</span>div<span class="token operator">></span>\n        <span class="token punctuation">{</span>\n          <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span><span class="token function">children</span><span class="token punctuation">(</span> child <span class="token operator">=></span> <span class="token punctuation">(</span>\n            <span class="token comment" spellcheck="true">// I want child props ex: ID</span>\n            <span class="token operator">&lt;</span>div onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>handleClick<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>\n          <span class="token punctuation">)</span><span class="token punctuation">)</span>\n        <span class="token punctuation">}</span>\n      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>\n    <span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n      </div>\n<p>先想了一個解決方法後開始google，看到這篇\b<a href="https://stackoverflow.com/questions/29810914/react-js-onclick-cant-pass-value-to-method">文章</a></p>\n<h4>Easy way</h4>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span><span class="token function">children</span><span class="token punctuation">(</span> child <span class="token operator">=></span> <span class="token punctuation">(</span>\n  <span class="token operator">&lt;</span>div onClick<span class="token operator">=</span><span class="token punctuation">{</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">handleClick</span><span class="token punctuation">(</span>child<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>\n<span class="token punctuation">)</span><span class="token punctuation">)</span>\n</code></pre>\n      </div>\n<p>這就是一般人直覺會想到的做法，但並不是太好。這網路上有很多文章，反正會有slightly performance issue(rebind與pure component等問題)，另外不好閱讀。</p>\n<h4>Better Way</h4>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Parent</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>\n  <span class="token operator">...</span>\n  onChildClick <span class="token operator">=</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    <span class="token operator">...</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token punctuation">(</span>\n      <span class="token operator">&lt;</span>div<span class="token operator">></span>\n        <span class="token punctuation">{</span>\n          <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span><span class="token function">children</span><span class="token punctuation">(</span> child <span class="token operator">=></span> <span class="token punctuation">(</span>\n            <span class="token comment" spellcheck="true">// I want child props ex: ID</span>\n            <span class="token operator">&lt;</span>Child onChildClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>onChildClick<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>\n          <span class="token punctuation">)</span><span class="token punctuation">)</span>\n        <span class="token punctuation">}</span>\n      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>\n    <span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>\n  <span class="token operator">...</span>\n  handleClick <span class="token operator">=</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span><span class="token function">onChildClick</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token punctuation">(</span>\n      <span class="token operator">&lt;</span>div onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>handleClick<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>\n    <span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n      </div>\n<p>這例子看起來很蠢，不過現實中很少map裡面長這麼簡單的，以前都寫這種寫法，所以就不知道怎麼回答寫在同一層的XD。</p>\n<p>不過我一開始認真想的是data-attr</p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Parent</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>\n  <span class="token operator">...</span>\n  handleClick <span class="token operator">=</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> cid <span class="token operator">=</span> e<span class="token punctuation">.</span>target<span class="token punctuation">.</span><span class="token function">getAttribute</span><span class="token punctuation">(</span><span class="token string">"data-cid"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token punctuation">(</span>\n      <span class="token operator">&lt;</span>div<span class="token operator">></span>\n        <span class="token punctuation">{</span>\n          <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span><span class="token function">children</span><span class="token punctuation">(</span> child <span class="token operator">=></span> <span class="token punctuation">(</span>\n            <span class="token comment" spellcheck="true">// I want child props ex: ID</span>\n            <span class="token operator">&lt;</span>div data<span class="token operator">-</span>cid<span class="token operator">=</span><span class="token punctuation">{</span>child<span class="token punctuation">.</span>id<span class="token punctuation">}</span> onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>handleClick<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>\n          <span class="token punctuation">)</span><span class="token punctuation">)</span>\n        <span class="token punctuation">}</span>\n      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>\n    <span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n      </div>\n<p>隱約記得在哪個文章看過(react官方網站?!人老了)</p>\n<p>最後，因為專案都用semantic-react啦\b...可以直接傳出data，用久了難怪忘光XDD，看了一下source code，使用lodash的invoke</p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code>handleClick <span class="token operator">=</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> <span class="token punctuation">{</span> disabled <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props\n\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>disabled<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    e<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n    <span class="token keyword">return</span>\n  <span class="token punctuation">}</span>\n\n  _<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">,</span> <span class="token string">\'onClick\'</span><span class="token punctuation">,</span> e<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre>\n      </div>\n<p>也算學到了新東西!!</p>'}},{node:{fields:{slug:"/posts/hoc_n_decorator/"},frontmatter:{title:"HOC in React",date:"2018-09-17T16:48",tags:["react","javascript"],release:!0},html:'<p><snippet>React強調composition > inheritance，利用許多小的component組合成大的comoponent</snippet></p>\n<p>其中，High-order component也是代替inheritance的一種方式。HOC為一個function，接收一個component為params，然後回傳另一個component。最常見的HOC就是react-redux的connect，此function幫助整個app可以綁定唯一的store，將邏輯與UI分離卻又很方便的建立component。</p>\n<blockquote>\n<p>hocFactory:: W: React.Component => E: React.Component</p>\n</blockquote>\n<p>對我來說，最大的好處就是不同的component可以使用HOC掛載相同的行為或屬性。</p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code><span class="token keyword">const</span> Logger <span class="token operator">=</span> <span class="token punctuation">(</span>WrappedComponent<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n\n <span class="token keyword">return</span> <span class="token keyword">class</span> <span class="token class-name">ClickLogger</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>\n    handleClick <span class="token operator">=></span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">return</span> <span class="token punctuation">(</span>\n        <span class="token operator">&lt;</span>WrappedComponent <span class="token punctuation">{</span><span class="token operator">...</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">}</span> onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>handleClick<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>\n      <span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n\n<span class="token punctuation">}</span>\n</code></pre>\n      </div>\n<p>上述的function可以綁定任何的component，也是為什麼composition比inheritance好的原因。不過這其實這應該回到oo design討論，若只是為了code reuse，完全不應該使用inheritance。\binheritance分為\bimplementation inheritance（實作繼承)與interface inheritance（介面繼承)，我們應該為了interface而繼承(is-a的概念)，而implementation inheritance則使用composition取代。</p>\n<p>並且，inheritance擁有最高的耦合度，在現在流行的functional progaming完全相反，或者說，functional progaming的一部份目的本來就是為了降低耦合度。</p>\n<p>另外一個使用情境就是對props做一些處理，例如修改或是新增props (props proxy)</p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code><span class="token keyword">const</span> Loggin <span class="token operator">=</span> <span class="token punctuation">(</span>WrappedComponent<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\n  <span class="token keyword">return</span> <span class="token keyword">class</span> <span class="token class-name">LogginWrap</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>\n\n    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">const</span> newProps <span class="token operator">=</span> <span class="token punctuation">{</span>\n        user<span class="token punctuation">:</span> currentLoggedInUser\n      <span class="token punctuation">}</span>\n\n      <span class="token keyword">return</span> <span class="token operator">&lt;</span>WrappedComponent\n        <span class="token punctuation">{</span>\n          <span class="token operator">...</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">,</span>\n          organization<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>organization<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n        <span class="token punctuation">}</span>\n        <span class="token punctuation">{</span> <span class="token operator">...</span>newProps <span class="token punctuation">}</span>\n      <span class="token operator">/</span><span class="token operator">></span>\n    <span class="token punctuation">}</span>\n\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n      </div>\n<p><a href="https://medium.com/@franleplant/react-higher-order-components-in-depth-cf9032ee6c3e">這篇文章</a>還有更多應用像是inheritance inversion(看了一下很有趣，debug part看起來很好用，另一個不知道使用境)，然後naming超實用!!</p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code>HOC<span class="token punctuation">.</span>displayName <span class="token operator">=</span> <span class="token template-string"><span class="token string">`HOC(</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token function">getDisplayName</span><span class="token punctuation">(</span>WrappedComponent<span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">)`</span></span>\n<span class="token comment" spellcheck="true">//or</span>\n<span class="token keyword">class</span> <span class="token class-name">HOC</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></span> <span class="token punctuation">{</span>\n  <span class="token keyword">static</span> displayName <span class="token operator">=</span> <span class="token template-string"><span class="token string">`HOC(</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token function">getDisplayName</span><span class="token punctuation">(</span>WrappedComponent<span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">)`</span></span>\n  <span class="token operator">...</span>\n<span class="token punctuation">}</span>\n</code></pre>\n      </div>\n<p>Decorator與Recompose研究一下，下一篇再介紹。</p>'}},{node:{fields:{slug:"/posts/react_context/"},frontmatter:{title:"React context認識",date:"2017-09-09T14:55",tags:["react","javascript"],release:!0},html:'<snippet>\ncontext是一個很少被使用的屬性，我想一方面在react的教學頁面不會特別提到這點，另一方面介紹的頁面就先警告一般人不要使用。一開始我也是看到警告就沒有研究了，不過在實際遇到情境與研究了HOC以後，確實是挺有趣的。\n</snippet>\n<h3>Context</h3>\n<p>react的<a href="https://facebook.github.io/react/docs/context.html">官方文章</a>中，會告訴你props要傳遞每個component很麻煩，所以有了context這個power api，不過下一秒又跟說不建議使用XD</p>\n<p>context的用法也相當簡單，這邊不太細講整體用法，請自己看官方文件</p>\n<p>總之，在你的context container加上getChildContext與childContextTypes</p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Parent</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>\n  <span class="token function">getChildContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token punctuation">{</span>key<span class="token punctuation">:</span> <span class="token string">"value"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token operator">...</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\nParent<span class="token punctuation">.</span>childContextTypes <span class="token operator">=</span> <span class="token punctuation">{</span>\n  key<span class="token punctuation">:</span> PropTypes<span class="token operator">...</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n</code></pre>\n      </div>\n<p>在你的child加上contextTypes，最後呼叫this.context使用</p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>\n\n  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> <span class="token punctuation">{</span> key <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>context<span class="token punctuation">;</span>\n    <span class="token operator">...</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\nChild<span class="token punctuation">.</span>childContextTypes <span class="token operator">=</span> <span class="token punctuation">{</span>\n  key<span class="token punctuation">:</span> PropTypes<span class="token operator">...</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n</code></pre>\n      </div>\n<p>為什麼不要使用context的原因</p>\n<ol>\n<li>\n<p>很難找到source<br/>\n這與react的特色完全相抵觸，react強調的是props的傳遞與資料的明確性，你的所有東西會照著flow走。而context打破了這個規則，你必須去翻你的source code。當然現在的IDE都很猛，可能也不是很care，但是跟原生react比，確實有這個問題。</p>\n</li>\n<li>\n<p>造成耦合度<br/>\n原本的component只要接收props就可以在任何地方，任何專案中使用，但是一但使用了context，你必須綁定某個parent，這樣是增加了耦合度。</p>\n</li>\n<li>\n<p>難以test<br/>\n如果有在寫test，因為component的data要從context取得而非props，實際想想就覺得很困難。</p>\n</li>\n<li>\n<p>語意不清與render問題<br/>\n從setState你可以馬上看的懂state要改變了，但是getChildContext是跟著setState一起的，這本身語意上就不清晰，另外因為getChildContext這個method會在props or state改變的時候被呼叫，所以你要改變context的值應該使用props or state(但這其實就是不好的做法)。<br/>\n因為child更新context會被shouldCompoentUpdate所擋下來。這邊並不是指child本身shouldCompoentUpdate，而是parent到child之間所有的component若是有實作shouldCompoentUpdate且return false，更大的機率可能用了PureComponent，這樣就會導致child更新失敗。<br/></p>\n<p>所以所以重點來了</p>\n<ol>\n<li>context不應該被改變(or shalow immutable)。</li>\n<li>承上，context只應該在constructor的時候收到一次。</li>\n</ol>\n<p>基於以上理由我們可以</p>\n<ol>\n<li>將context由props or state搬到外面轉為Dependency injection。</li>\n<li>加上observe pattern，訂閱Dependency Object，當Object改變時，主動告知底下改變。</li>\n</ol>\n<p><a href="https://medium.com/@mweststrate/how-to-safely-use-react-context-b7e343eff076">這篇必看!!!</a></p>\n</li>\n</ol>\n<p>打完這篇我也將專案中的context先拆掉了(因為本來就可以用provider+hoc的方式處理)，但是使用provider本身也就有相當的耦合度，主要還是看架構，再來決定你的component要如何設計囉。</p>'}},{node:{fields:{slug:"/posts/connect_n_di/"},frontmatter:{title:"DI & React HOC &....",date:"2017-09-02T00:35",tags:["javascript","Design Pattern"],release:!0},html:'<p><snippet>已前沒有學過design pattern，雖然看過很多文章，但是寫前端還是很少會思考這個問題。不過實際上，如果常常會整理自己code的人一定或多或少會用到一些pattern觀念。其實在使用framework的時候也有很多己經包進去的pattern了。</snippet></p>\n<p>這次要來講很夯的DI(dependency injection)，首先要先了解控制反轉(inversion of control)。</p>\n<h3>控制反轉</h3>\n<p>通常會說到這個詞都是OO設計，概念是依賴對象 (Dependent Object) &#x26; 被依賴對象（Dependency Object）</p>\n<p></p>\n<p>物件導向中，會很常說到耦合度，當物件彼此交互引用(繼承)時，關聯性很大，其中的一個物件掛了，整體就不能動了，稱之為高耦合性。</p>\n<p></p>\n<p>在控制反轉的設計中，巧妙的加入一個容器。物件需要別的物件的東西，只需要從容器注入。原本從頭到尾由類別控制，但是控制反轉將控制權交到了容器手上，也可以從另一個角度來看，傳統的方式是高階(parent)模組建立低階(child)模組，現在則是低階模組注入高階模組，可以大幅降低耦合度。</p>\n<p>舉例</p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Lecture</span> <span class="token punctuation">{</span>\n  Lecturer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  doSomething <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>Lecturer<span class="token punctuation">.</span><span class="token function">Speak</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n      </div>\n<p>假設B做了演講這件事後，隔天換成C要演講，那就得再造一個新的class。</p>\n<p>IoC寫法</p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Lecture</span> <span class="token punctuation">{</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span>Lecturer<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>Lecturer <span class="token operator">=</span> Lecturer<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  doSomething <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>Lecturer<span class="token punctuation">.</span><span class="token function">Speak</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n      </div>\n<p>不要在容器裡面註冊物件，而是將容器透過介面，將物件注入容器。"Don\'t call me, I\'ll call you."</p>\n<p>javascript的世界中，並沒有介面這種東西，屬於ducking type，這點需特別注意。</p>\n<p>另外javascript有一種很常見的控制反轉 - callback。你將你的控制權交給callback(想像成容器)，但這是不好的做法，常常引用的\bcallback都是來自第三方的api，你被迫交出控制權，很難debug，也無法保証你程式的 \bcontinuation。</p>\n<p>這邊你須要使用promise來控制逆反轉(uninversion of control)，所以說design pattern可以帶來一些好處，但不一定百分之百就是最好的。</p>\n<p>另外控制權是相對的，什麼叫做"失去控制權"是很抽像的，甚至連網頁的btn click都算控制反轉(是你將資料交(注入)紿程式)，我們應該要了解的是控制反轉的好處與使用情境。</p>\n<p>簡單來說，將程式的flow以不同的方式運行都是一種控制反轉的概念。</p>\n<h3>Dependency Injection</h3>\n<p>這邊好像沒啥好介紹的，DI是IoC的子集合，或是說是一種實現IoC的設計模型。以Spring為例，就是有一個IoC Container，透過xml,json...將每一個注入的模組定義好，以後就可以靠文檔，方便抽換模組。</p>\n<h3>DI vs Strategy Pattern vs Factory Pattern</h3>\n<p>Strategy Pattern是軟體設計模型，強調的是在runtime的時候選擇一個實作，更重要的是選擇，你要先知道你的情境是什麼。DI是物件導向設計，強調的是容器與解耦的概念。你可以在不同情境的時候，注入不同的方法。解耦跟抽換實作是完全不一樣的概念，抽換仍然是相依在高階模組之下。Factory Pattern也是常常被拿來與Strategy Pattern做比較的，Factory的做用是create new objects，而Strategy是做implement居多。</p>\n<h3>React HOC &#x26; Dependency Injection</h3>\n<p>React裡面常常會遇到一種情況，就是props hell，從parent要給某個grandchild值需要不斷的傳遞props，這樣其實造成了高耦合度，而且中間的component明明就沒有使用props，是非常不好的寫法。因此可以使用HOC注入資料就好。</p>\n<p>原本寫這篇文章是已為HOC是Dependency injection，認真研究以後才知道比較像是Decorator Pattern，但是React裡面還是可以利用context做Dependency injection，最近工作上遇到的疑問全部都混在一起變成撒尿牛丸了XDDD</p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">HOC</span><span class="token punctuation">(</span>Component<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> ComponentHOC <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>\n    render <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">return</span> <span class="token operator">&lt;</span>Component\n                <span class="token punctuation">{</span><span class="token operator">...</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">}</span>\n                <span class="token punctuation">{</span><span class="token operator">...</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">}</span>\n                enchance<span class="token operator">=</span><span class="token punctuation">{</span><span class="token template-string"><span class="token string">`YOUR ENCHANE DATA`</span></span><span class="token punctuation">}</span>\n              <span class="token operator">/</span><span class="token operator">></span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n      </div>\n<p>HOC還須要注入資料，就可以使用react context，這邊先不介紹context用法(但請警慎使用)。在所有常見的provider library裡面幾乎都有使用，像i18n\bext reac\bt、socket provider、react-router、跟最常用的react-redux。這些都同時使用Decorator Pattern &#x26; Dependency injection，但這兩個概念是不同的。react中常見一起使用，所以才造成我的誤解。</p>\n<p>在寫這篇文章的時候爬到了這個<a href="https://github.com/krasimir/react-in-patterns">github</a>，實在是很過癮，再花時間慢慢看。</p>\n<p>最近才開始學習design pattern，若是有錯請指教，至於hoc與es6 Decorator與context之後再寫別篇文章了(累)</p>\n<p><a href="http://madphilosophy.idv.tw/2016/12/24/springmvc-%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%89inversion-of-control%E8%88%87%E4%BE%9D%E8%B3%B4%E6%B3%A8%E5%85%A5dependency-injection/?i=1">圖片來源</a></p>'
}},{node:{fields:{slug:"/posts/sass-signup-flow/"},frontmatter:{title:"3 Common SaaS Sign-Up Flows",date:"2017-08-20T22:03",tags:["UI/UX"],release:!0},html:'<p><snippet>譯: <a href="https://conversionxl.com/blog/saas-signup-flows/">3 Common SaaS Sign-Up Flows (and a Friction-Based Analysis)</a></snippet></p>\n<p>非心理系出身，若是有專有名詞翻錯，請指正。</p>\n<p>摩擦</p>\n<blockquote>\n<p>當參訪者嘗試完成一個動作的時候所遇到的心理上的反抗，是轉換率殺手。</p>\n</blockquote>\n<p>你可以試著優化產品的價值主張與call to action buttons(行動按鈕)，但若是你的註冊流程包涵了太多的摩擦，你就會流失你的客戶。</p>\n<p>減少摩擦就是最有效率增加轉換率的方式。然而，如果你只是胡亂猜測的話，是很難去辨識摩擦來源的。</p>\n<p>摩擦會出現在網頁的各處，我們這邊只講註冊流程，也是通常摩擦最容易發生的地方。</p>\n<h3>摩擦與註冊流程</h3>\n<p>摩擦就是使用者必須要多精通註冊流程的測量。</p>\n<p>雖然因為多樣性與客觀性很難去量化標準，但還是可以使用三種因子去做評估</p>\n<ol>\n<li>\n<p>完成步驟 - 使用者會經過的一連串的頁面與步驟的數量。</p>\n</li>\n<li>\n<p>資訊代價 - 使用者必須填寫的資訊數量。</p>\n</li>\n<li>\n<p>付出投資 - 使用者必須做的決定與額外須要完成的活動。(像是email認証，CAPTCHA，其他...)</p>\n</li>\n</ol>\n<p>這邊有幾種註冊流程的設計方式，他們各自有優缺點。但是最終的目的都是為了減少摩擦，最大價值化客戶與利潤。</p>\n<h3>三種常見的註冊流程與如何減少摩擦</h3>\n<p>雖然市面上有很多種註冊流程，通常可以分為以下三類，各自都有優缺點，當然也要考慮到你的產品與使用情境。\n總而言之，這裡有三種常見的使用情境與評論。</p>\n<ol>\n<li>\n<p>完整的流程後登入app</p>\n<blockquote>\n<p>註冊(Email+密碼) -> 帳號設置 -> Email確認 -> App</p>\n</blockquote>\n</li>\n</ol>\n<p>這差不多是現今最常見的註冊流程，使用者先將所有資訊填好，之後才能登入程式。</p>\n<h4>這有什麼好處</h4>\n<p>對於初始者非常熟悉此流程，人腦對於流程如何進行會先定義心智模型。所以當他們看到相關的模型，在認知上只須要花很少的力。因此我們對於這個流程就感到不錯。</p>\n<p>另外一個主要的原因就是我們可以確保垃圾郵件發送者會盡可能的遠離我們的app。安全性十足。</p>\n<h4>可能做錯了什麼</h4>\n<p>在使用者進入app之前問太多資訊可能會導致退火。</p>\n<p>營運試著獲得更多資訊，但越多資訊填寫，同時也產生越多摩擦。</p>\n<p>如果你試著一開始就問更多的資訊，確認有解釋每一個動作以便消除摩擦。</p>\n<p>Samuel Hulick:</p>\n<blockquote>\n<p>當使用者註冊的時候，他們的注意力是很珍貴的。你可以想像成在宇宙中被釋放的一小撮空氣 - 你必須盡可能的去使用它當它還在的時候。 最好的方式是靠減少摩擦 - 意思是定義清楚與有意義的動作將會提升使用者通過一開始的流程。<br />\n舉例來說，如果你想要一個人去做pizza，你不會一開始說"讓我們從揉捏麵糰與煨醬開始..."<br />\n你應該說"讓我們來做個pizza，我們會從揉捏麵糰與煨醬開始"當你圍繞著最終目標而建構兩個活動，這幫助使用者了解為什麼這些是很重要的然要建立動機去完成他們。</p>\n</blockquote>\n<p>總結一下，如杲你想要讓使用者通過註冊並且維持使用者體驗，確認他們知道為什麼他們必須完成每一項任務。</p>\n<ol start="2">\n<li>\n<p>再app登入後才設置帳號</p>\n<blockquote>\n<p>註冊(email) -> app -> email認証 -> 設置帳號</p>\n</blockquote>\n</li>\n</ol>\n<p>如同你就看見的，使用者在輸入email之後可以立即登入app，再那之後使用者被要求驗証email，接著就可以使用app的更多細節。</p>\n<h4>這有什麼好處</h4>\n<p>延遲輸入必要的資訊可以減少很多的摩擦 - 像是密碼。</p>\n<p>想出一個好的，具有安全性的密碼是一項艱懼的任務，早期移除密碼需求(至少在認証之前)對於使用者來說更簡單，然後你仍然拿到他們的email可以進行再行銷。</p>\n<p>Samuel Hulick:</p>\n<blockquote>\n<p>Email認証還是很重要的一環，我還沒有找到一個好的理由去使用一個全新的註冊方式，告訢他們email收件會使他們分心而喪失了更進一步了解產品的機會。</p>\n</blockquote>\n<p>邏輯很簡單:如果使用者喜歡你的產品，他們會更願意去做他們的email認証與設置他們的帳號。</p>\n<p>如果你跟著步驟走，你會注意到兩件事情:</p>\n<ul>\n<li>整個流程是使用者中心的 - 人們在花費多餘的精力設置帳號前就能進到產品中。</li>\n<li>願意完整將帳號建置好的使用者是很重要的評估者。你可以很容易的從平常的註冊中分類，因此，你可以集中的制訂你的行銷與銷售策略，減少花費在假客戶上的努力。</li>\n</ul>\n<h4>可能做錯了什麼</h4>\n<p>有一個缺點:你不能減少垃圾郵件發送者與假客戶。同時間，若是有客戶想要探索產品，認証信箱還是一個無可避免的摩擦。</p>\n<p>而且，你不會取得太多的使用者資訊，有時候，因為一連串的前置行為，會產生承諾偏差，代表更高品質的客戶。通常來說，越少的資訊能取得的是更多"質+量"的使用者。</p>\n<ol start="3">\n<li>\n<p>直接進入app裡面</p>\n<blockquote>\n<p>app -> 註冊(email+ 密碼) -> email確認 -> 帳號設置</p>\n</blockquote>\n</li>\n</ol>\n<p>最懶與最輕鬆的註冊流程，使用者可以直接進入app，在那之後才會被提示註冊。</p>\n<h4>這有什麼好處</h4>\n<p>這種註冊流程最大的好處就是一點摩擦都沒有，一開始的時候不需要註程。</p>\n<p>Luke Wroblewski相信註冊流程不能存在。相反的，他相信這種漸進式參與(那是他如何稱呼慢註冊的)對於初次的使用者是最好的流程。</p>\n<p>展示你的產品，讓你的客戶獲得馬上的體驗，只有他們想使用進階的功能時才會進一步詢問他們資訊。他推薦這是最好的實作。</p>\n<p>Luke Wroblewski:</p>\n<blockquote>\n<p>當策畫使用者對你網路服務的初始體驗時，想想你可以如何使用漸進式參與來避免註冊流程。<br>\n如果你不選擇漸進式參與的方法，確保紿予潛在客戶他們該如何使用你的服務與該注意的事情等足夠的資訊。<br>\n如果你選擇了為潛在客戶自動產生帳號，確保他們有清楚的方式進入他們的帳號。<br>\n不使用漸進式參與會很客易使使用者在經過多頁的註冊與input欄位中分散他們的注意力。這會造成很大的機率減少效率與使使用者不開心。</p>\n</blockquote>\n<h4>可能做錯了什麼</h4>\n<p>每個硬幣都有正反面，沒有一個是例外的。</p>\n<p>從商業來看，你會失去很珍貴的客戶資訊 - 他們的email。所以你不可能碰處到那些你期望的客戶。你只能依賴他們依照他們自己的根據去進行的動作。</p>\n<p>如果你的產品才剛開始，接觸你的客戶是非常困難的。但這是唯一的方式能得到即時的回饋讓你可以持續的潤飾與測試你的產品。</p>\n<p>同時這個模型也有客戶端的缺點。 Harry Brignull嘗試了這個方式，下面是他必須說的</p>\n<p>Harry Brignull:</p>\n<blockquote>\n<p>我們使用慢註冊(也稱被動註冊，漸進註冊)設計了一個搜尋工作的網站，人們在申請工作與設置email通知前不須要註冊。<br>\n這在增加轉換率上非常的成功，我們決定在發佈工作的UI上也做同樣的事情 - 這是一個讓顧主發佈他們工作廣告、多樣分類然後付款的地方。<br>\n我們做了易用性測試，然後每個使用過的招募者都紿了不及格的分數。為什麼?因為他們不放心花了15分鍾所寫的工作內容沒有被存在安全的地方。他們寧願使用提前註冊的版本。<br>\n這一次很有趣，使用者研究指出了可以大幅減少開發的選項，這同時也告訴我們你不能盲目地將一個情境下的設計模式複製到另一個情境然後期望可以很好的整合與成功。情境才是最關鍵的。</p>\n</blockquote>\n<p>然後，這邊又提出另一個問題 - 摩擦總是壞人嗎?</p>\n<h3>摩擦有時候對於註冊流程是好的</h3>\n<p>摩擦被故意加入註冊流程可以被示為目的導向摩擦。通常可以造成下列的效果:</p>\n<ul>\n<li>增加註冊的質量 或</li>\n<li>改善使用者戶動</li>\n</ul>\n<h3>結論</h3>\n<p>每一種的註冊流程都有各自的優缺點，他們都適合不同的情境。沒有一件事情是決對會增加使用者體驗或是轉換率的。試著反問自己:</p>\n<ul>\n<li>\n<p>目的是什麼?什麼是你嘗試在註冊流程完成的然後透過什麼步驟可以達成。獲得資訊、引導質量、引導數量、使用者體驗 - 什麼是你想要達成的。</p>\n</li>\n<li>\n<p>什麼是你的觀眾所愛的?不同的人會有不一樣的隱私故慮，他們有不同的吸引廣度，他們評量時間與安全的方式不同。對你的觀眾做測試。</p>\n</li>\n<li>\n<p>產品如何?有多複雜?是要用來解決什麼問題?為你的目標巿場建置產品，然後讓使用流程越流暢越好。</p>\n</li>\n</ul>'}}]}},pathContext:{offset:0,paginations:6,total:13}}}});
//# sourceMappingURL=path---index-c395b24e293cc09642c1.js.map
webpackJsonp([0x81b8806e4260],{"./node_modules/json-loader/index.js!./.cache/json/index.json":function(n,s){n.exports={data:{allMarkdownRemark:{edges:[{node:{fields:{slug:"/posts/javascript-memory/"},frontmatter:{title:"Javascript memory in use",date:"2018-04-29T16:18",tags:["mechanic"],release:!0},html:'<snippet>\n  整個四月都在忙轉職的事情，而且跑去刷leetcode啦，結果要寫的東西越來越多啦，才發現我連event loop都還沒寫.\n</snippet>\n<p>這篇要介紹的是javascript的memory的機制，在認識event loop的時候知道的queue與stack，不過還缺一個heap，還可以順便提一下primitive與object。</p>\n<p>在js的語言中，只有兩種資料型態</p>\n<h4>primitive type - 基本型別</h4>\n<p>\b\n包涵以下六種</p>\n<ul>\n<li>string</li>\n<li>number</li>\n<li>boolean</li>\n<li>null</li>\n<li>undefined</li>\n<li>symbol(es6加入)</li>\n</ul>\n<h4>object - 物件 沒啥好說的</h4>\n<p>在string、number、boolean與symbol有所謂的wrapper object(封裝物件?網路上很多種翻譯)</p>\n<p>在使用這些primitive的時候，JS會臨時的create一個new [Type] object(ex: new Number(8))，然後進行操作完後就拋棄。請永遠不要用new的方式去初始化參數，原因是啥我忘了，大概在比較上有些不一樣的與速度比一般直接宣告慢。</p>\n<p>也不要在primitive加properties，以下有一個很簡單的例子</p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code><span class="token keyword">var</span> s <span class="token operator">=</span> <span class="token string">\'Hello World\'</span><span class="token punctuation">;</span>\ns<span class="token punctuation">.</span>len <span class="token operator">=</span> <span class="token string">\'len\'</span><span class="token punctuation">;</span>\n<span class="token keyword">var</span> t <span class="token operator">=</span> s<span class="token punctuation">.</span>len<span class="token punctuation">;</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// undefined</span>\n</code></pre>\n      </div>\n<p>因為每次操作的時候，都會產生一個新的object，然後就釋放掉，所以t的那行拿不到上一行s.len的值。</p>\n<p>primitive是call by value的</p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>\n<span class="token keyword">var</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>\nb <span class="token operator">=</span> <span class="token number">456</span><span class="token punctuation">;</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 123</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 456</span>\n</code></pre>\n      </div>\n<p>object是call by reference的</p>\n<p>array是normal object + "special function" 所以也是call by reference</p>\n<p>然後function也是一種特殊object...(callable object)\n(要記的清楚好麻煩XD)</p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>\n  test<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">var</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>\n\nb<span class="token punctuation">.</span>test <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>test<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//false</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>test<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//false</span>\n</code></pre>\n      </div>\n<p>PS. 有人說更正確的為call by sharing</p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code><span class="token keyword">var</span> bar<span class="token punctuation">;</span>\n<span class="token keyword">var</span> foo <span class="token operator">=</span> bar<span class="token punctuation">;</span>\nbar <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">\'key\'</span> <span class="token punctuation">:</span> <span class="token string">\'value\'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo <span class="token punctuation">,</span> bar <span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment" spellcheck="true">// if call by reference?</span>\n</code></pre>\n      </div>\n<p>說的太深又是一篇文章，先略過吧。</p>\n<br/>\n<p>那進入我們的memory介紹</p>\n<p>因為javascript是dynamic language，變數可能隨時改變型別，所以記憶體是動態分配的。</p>\n<p>不管是primitive或是object皆儲存在heap記憶體中。</p>\n<p>而stack會保存heap裡面變數的ref</p>\n<p>\n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 400px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 73.875%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAABYlAAAWJQFJUiTwAAABl0lEQVQ4y22U64rCQAyF+/6P5U9BRKSVKgqtKBarVbFeqja7X+AMs4sDIWMml5OT2MR+z/v9drndbtZ1nd8/n4/1fW+v18vvCPbn82lxTPyGf0LA4/HwRLPZzDabjQdhQyO83e9317vdziaTib8Ti11+iCckO7osSzsej16JR2wkEUrs+HKwKRY77/gmQpNlmaVpaqvVytbrtbd/Pp8DDWj8ELVLIlGEeEIZqLbf712oJoRI27ZWVZVtt9uAWjHiUfwmagf+ptOpLRYLT6pWVVmdxIk0tD8IRT4/aHm5XPpvWkRTTOSjscdJiBdC7gEh3OV57ggZjNpFRLqScAQCu5AHhFobhkAyIVR1TTAeAm+s2Hg8DnQEhOJlOBw6SjgUOvEXc8rRHmoo8g0IL5eLFUXhwl12OTZNE3hVe1p42cKUr9erjUYjGwwGPmkmLkSsDBrkh8PBi2i6X9cmbgkOEQpgQwuBEHHXP+brYms1qA66+XxudV17eySLV0JB8UdBWxLWRlBJQFIQnk6n0LI2IP5gYP+PWn4/3Z+MTP2B0q8AAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"\n        alt="stack_n_heap.png"\n        title=""\n        src="/static/90b51a4be5dbfff29bcca49d861a0e83-54202.png"\n        srcset="/static/90b51a4be5dbfff29bcca49d861a0e83-10827.png 148w,\n/static/90b51a4be5dbfff29bcca49d861a0e83-3b047.png 295w,\n/static/90b51a4be5dbfff29bcca49d861a0e83-54202.png 590w,\n/static/90b51a4be5dbfff29bcca49d861a0e83-83423.png 800w"\n        sizes="(max-width: 400px) 100vw, 400px"\n      />\n    </span>\n  </span>\n  </p>\n<p>primitive跟object的差別在於，primitive會在heap create一個新的，然後將新的ref傳出去，而object不會，只會將現有的ref傳出去。最後，js會自動分辨型別，決定拿到的ref是\nprimitive還是object。</p>\n<p>網路上也能找到這張圖</p>\n<p>\n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 436px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 50.68807339449541%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsSAAALEgHS3X78AAABMElEQVQoz5WSXWuDMBSG/f//pLeyloHd7UZX8bOuxsTP6lqsvfDGgaDvkqwtE7XQAwFPkvOeJ+9RwTWqcwnHcZCkGZ4JQnx8bnX0/V+uLBYLvK5WcjNJErmyLMPhcEAURZMitmVi+bLEev0GEgSI4xhpmso6xbZtFEUhEyEmhEReliUopSMxwzCgqipOp5O8exPK8xzH4xHK5uMdWV5MkgS8+/8IwxBVVfHGMSijiOJkVPOQkBByv+j7Puq6lt+MsXlCQ9fxtd8jIAGa5mfQTXjYc7dd1+VnzX2fXX0LuXBefA8JLcuaJRRPFudt2w6KhLezhPp2g50nCAkYZfB2HjxOHHECTdPQdd3IJxrwuyzkdGPvFdM0n5rybVizhEKQ8cLz5TIqnPsPKX+NGNgU4S9bN+yCyM8DLAAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"\n        alt="stack_n_heap2.png"\n        title=""\n        src="/static/e43d40986d2db92e23897b29c69e1700-704f6.png"\n        srcset="/static/e43d40986d2db92e23897b29c69e1700-e054b.png 148w,\n/static/e43d40986d2db92e23897b29c69e1700-1e7c4.png 295w,\n/static/e43d40986d2db92e23897b29c69e1700-704f6.png 436w"\n        sizes="(max-width: 436px) 100vw, 436px"\n      />\n    </span>\n  </span>\n  </p>\n<p>primitive是直接存在stack裡面的，也是網路上比較多的文章寫的，我認為就是看環境complier的實作方式。</p>\n<p>由於這張圖，有人說js只能call by value的，只是傳出去的時候，primitive的value是實際的值，而object的\bvalue的addr。</p>\n<p><a href="https://stackoverflow.com/questions/33125547/javascript-string-stored-on-stack">這篇</a>寫的很好</p>\n<blockquote>\n<p>In any case, for the JS programmer, worrying about stacks and heaps is somewhere between meaningless and distracting. It\'s more important to understand the behavior of various types of values.</p>\n</blockquote>\n<p>我認為primitive存在哪裡並不是這麼重要(但primitive與object的比較還有heap memory還是很重要)。然後我個人偏好第一種說法，因為stack的size應為fixed，才有使用stack的優點。</p>\n<h4>stack &#x26; heap 比較</h4>\n<table>\n<thead>\n<tr>\n<th>Stack</th>\n<th>Heap</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>在compile時期知道size</td>\n<td>在runtime分配size</td>\n</tr>\n<tr>\n<td>FILO(跟function exec順序有關)</td>\n<td>沒有特別順序</td>\n</tr>\n<tr>\n<td>靜態分配</td>\n<td>動態分配</td>\n</tr>\n</tbody>\n</table>\n<h3>memory leak issue</h3>\n<p>在以前沒有es6與module(common js require)之前，常常用clousre保存變數。那時候是dom的操作，加上瀏覽器引擎沒這麼好，電腦沒這麼強，對於memory要求比較care。現在的話使用eco-system寫好的framework，加上原生的module功能，很少人會特別說到memory的問題，不過對於SPA來說，使用者瀏覽的時間偏長(更正確應該說SPA所有操作都是在同一頁面的javascript)，如果這頁面是面對眾多的user還是需要注意。</p>\n<p>javascript是動態語言會自己分配memory，同樣的也有自己的GC機制。</p>\n<p>最簡單的GC演算法，會偵測變數是否有被其他人引用，若是沒有就會進行memory回收。</p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code><span class="token keyword">var</span> obj1 <span class="token operator">=</span> <span class="token punctuation">{</span>\n  obj2<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n<span class="token comment" spellcheck="true">// 2 objs create</span>\n\n<span class="token keyword">var</span> obj3 <span class="token operator">=</span> obj1<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// obj1 got 2 ref(itself &amp; obj3)</span>\n\n<span class="token keyword">var</span> obj1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// obj1 got 1 ref(obj3)</span>\n\n<span class="token keyword">var</span> obj4 <span class="token operator">=</span> obj3<span class="token punctuation">.</span>obj2 <span class="token comment" spellcheck="true">// obj2 got 2 ref(obj3\'s property &amp; obj4)</span>\n\nobj3 <span class="token operator">=</span> <span class="token number">456</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// no one need obj1, obj1 got GCed</span>\n\nobj4 <span class="token operator">=</span> <span class="token keyword">null</span> <span class="token comment" spellcheck="true">// no one need obj2, obj2 got GCed</span>\n</code></pre>\n      </div>\n<p>但這無法解決cycle ref</p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">var</span> o1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token keyword">var</span> o2 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n  o1<span class="token punctuation">.</span>p <span class="token operator">=</span> o2<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// o1 references o2</span>\n  o2<span class="token punctuation">.</span>p <span class="token operator">=</span> o1<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// o2 references o1. This creates a cycle.</span>\n<span class="token punctuation">}</span>\n\n<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre>\n      </div>\n<p>所以後來GC機制改用Mark-and-sweep演算法，簡言之從global當作root，往chilren一步一步走，將走過的變數設為active。最後將非active的變數釋放掉。</p>\n<p>所以不管有沒有cycle循環，只要root抵達不了就會回收。2012的時候，大部份的modern browser更新了此GC。</p>\n<p>雖說了這麼多，但還是有四個常見的JS memory leak</p>\n<h4>global variable</h4>\n<p>大家都是知道少用global var，且在global = root情況下是不會回收的，比較常見的是</p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    bar <span class="token operator">=</span> <span class="token string">"some text"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// oops</span>\n<span class="token punctuation">}</span>\n</code></pre>\n      </div>\n<p>另外適時的使用global var是好的，不過當不用的時候可以ressign it或是 delete property。</p>\n<h4>timer &#x26; callback</h4>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code><span class="token keyword">var</span> data <span class="token operator">=</span> <span class="token string">\'123\'</span><span class="token punctuation">;</span>\n\n<span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n  <span class="token keyword">var</span> dom <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">\'test\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  test<span class="token punctuation">.</span>innerHtml <span class="token operator">=</span> data<span class="token punctuation">;</span>\n  <span class="token comment" spellcheck="true">// might be better</span>\n  <span class="token comment" spellcheck="true">// document.getElementById(\'test\').innerHtml = data;</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span>\n\n<span class="token comment" spellcheck="true">// data never GCed</span>\n</code></pre>\n      </div>\n<p>由於dom有可能從頁面上消失掉，所以包在function裡面是很多餘的</p>\n<p>另外data被Interval event使用著，所以never GCed</p>\n<p>上面的better寫法除了說減少多餘以外，另外因為不用宣告var，memory上略好一點</p>\n<p>不過code的<a href="https://stackoverflow.com/questions/8766220/javascript-declaring-variables-or-not">可讀性</a>更重要，我覺得最重要的應該是data不能被GC</p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code><span class="token keyword">var</span> button<span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">\'button\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nbutton<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">\'click\'</span><span class="token punctuation">,</span> onClick<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment" spellcheck="true">//remove yourself if not need</span>\nbutton<span class="token punctuation">.</span><span class="token function">removeEventListener</span><span class="token punctuation">(</span><span class="token string">\'click\'</span><span class="token punctuation">,</span> onClick<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre>\n      </div>\n<p>但聽說現在modern的瀏覽器都會幫忙檢查observer相關的問題了</p>\n<p>以前都需要自己寫removeListener before remove dom現在就不用囉(但寫了才是有quality的code，而且還是會有非modern browser的使用者)</p>\n<h4>額外的dom參考</h4>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code><span class="token keyword">var</span> elements <span class="token operator">=</span> <span class="token punctuation">{</span>\n    button<span class="token punctuation">:</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">\'button\'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n    image<span class="token punctuation">:</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">\'image\'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n    text<span class="token punctuation">:</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">\'text\'</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token keyword">function</span> <span class="token function">doStuff</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    image<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">\'http://some.url/image\'</span><span class="token punctuation">;</span>\n    button<span class="token punctuation">.</span><span class="token function">click</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>text<span class="token punctuation">.</span>innerHTML<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token comment" spellcheck="true">// Much more logic</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">function</span> <span class="token function">removeButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment" spellcheck="true">// The button is a direct child of body.</span>\n    document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">\'button\'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token comment" spellcheck="true">// At this point, we still have a reference to #button in the global</span>\n    <span class="token comment" spellcheck="true">// elements dictionary. In other words, the button element is still in</span>\n    <span class="token comment" spellcheck="true">// memory and cannot be collected by the GC.</span>\n<span class="token punctuation">}</span>\n</code></pre>\n      </div>\n<p>有時候因為方便，會在js裡面寫hash map，對於dom如同有兩個ref(one from dom tree, one from js)。</p>\n<p>如果你只從dom tree刪除，因為還有js的ref，所以memory無法GC</p>\n<p>特別的是如果你對一個td做記憶，然後移掉整個table，最後整個table無法被GC(因為必須同時記得他的parent)</p>\n<p>已經很少對於dom進行直接操作，不過想想以前好像寫過許多這種ng行為XD</p>\n<h4>Closure</h4>\n<p>實務上可能每天都在用closure，也有一些很tricky的行為</p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code><span class="token keyword">var</span> theThing <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n<span class="token keyword">var</span> replaceThing <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">var</span> originalThing <span class="token operator">=</span> theThing<span class="token punctuation">;</span>\n  <span class="token keyword">var</span> unused <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>originalThing<span class="token punctuation">)</span>\n      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"hi"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n  theThing <span class="token operator">=</span> <span class="token punctuation">{</span>\n    longStr<span class="token punctuation">:</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">1000000</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">\'*\'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n    someMethod<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>someMessage<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token function">setInterval</span><span class="token punctuation">(</span>replaceThing<span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre>\n      </div>\n<p>網路的文章我看了很久，我不確定我的說法是不是對的</p>\n<p>因為theThing在replaceThing裡面被引用了，而someMethod是一個closure，其中的一個free variable是unused，但因為unused也是closures，然後同樣parent scope中的closures會互相shared scope。在這個unused裡面又用到了originalThing(引用了上個循環的thingThing)，所以造成這個"上一次"的theThing也需要被記憶不能被GC。</p>\n<p>我將unused移除，並且用chrome dev tool查看，確實有unused會memory leak，沒有的就不會。</p>\n<p>其實任何的function在建立時皆為一個closure，並不是function retrun function才是closure。有些定義是需要有free variables才算closure。</p>\n<p>但由上面的整理也得知，就算closure裡面有許多的var，只要沒有被引用，就不會有memory的問題啦(不過無用的var eslint應該會警告)</p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code><span class="token comment" spellcheck="true">// y沒用到會自己被回收，x就會一直保存</span>\n\b<span class="token keyword">const</span> test <span class="token operator">=</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span> <span class="token operator">=></span> z <span class="token operator">=></span> x <span class="token operator">+</span> z<span class="token punctuation">;</span>\n</code></pre>\n      </div>\n<p>實際喔，我覺得還是memory detect in action吧 XD，畢竟js這麼神奇。重點是當你從工具中察覺到了memory leak的時候，是否能歸納出是哪種問題。</p>\n<br>\n<p>memory可以參考<a href="https://segmentfault.com/a/1190000007536949">此</a></p>\n<p>memory leak可以參考<a href="https://auth0.com/blog/four-types-of-leaks-in-your-javascript-code-and-how-to-get-rid-of-them/">此</a></p>'}},{node:{fields:{slug:"/posts/javascript-context/"},frontmatter:{title:"Javascript context & execution context",date:"2018-03-25T19:49",tags:["mechanic"],release:!0},html:'<snippet>\n  這邊試著整理一些javscript的context概念(教練我原本只想寫event loop啊，越寫越多orz...)\n</snippet>\n<p>先說說js function，在w3c的\b<a href="https://www.w3schools.com/js/js_function_invocation.asp">定義</a>中，呼叫一個function稱為invoke。</p>\n<p>在看js文章與執行function的時候當會看到一個字 - 執行環境(Execution Context)</p>\n<p>Execution Context就是執行javascript時候的環境(有講跟沒講一樣XD)，更準確的來說，上下文環境，確認執行時候的this, var, method...</p>\n<p>Execution Context有三種</p>\n<ol>\n<li>Gobal Execution Context - 一開始的地方，browser來說就是window</li>\n<li>Functional Execution Context - 執行function的地方</li>\n<li>Eval - 不常用</li>\n</ol>\n<p>當js invoke一個function時，會從global開始呼叫function，並且建立execution context，如果有很多function，就會一層疊一層的，此稱為execution context stack，而我們執行function的方式稱之為call stack。</p>\n<p>js建立execution context有兩個步驟</p>\n<ol>\n<li>建立階段</li>\n<li>執行階段</li>\n</ol>\n<h4>建立階段</h4>\n<ol>\n<li>建立activation object or the variable object\nvariable object指的是存放execution context scope data的物件，是一個抽象的概念，在不同的\bcontext裡面實作方式(存放的東西)是不一樣的。\n在global context中的variable object等同於自己，並且可以直接對變數引用，所以你能向下面一樣呼叫</li>\n</ol>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">\'test\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token function">alert</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// directly, is found in VO(globalContext): "test"</span>\n\n<span class="token function">alert</span><span class="token punctuation">(</span>window<span class="token punctuation">[</span><span class="token string">\'a\'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// indirectly via global === VO(globalContext): "test"</span>\n<span class="token function">alert</span><span class="token punctuation">(</span>a <span class="token operator">===</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span>\n</code></pre>\n      </div>\n<p>在function \bcontext中的VO稱之activation object，不能直接被引用，裡面要放入function arguments，context的var與function定義。</p>\n<ul>\n<li>\n<p>對於每一個var，js會幫AO create一個property with value undefined，如果存在property就略過。</p>\n</li>\n<li>\n<p>建立property for arg，把arguments object丟進去(reference)</p>\n</li>\n<li>\n<p>對於function，js會create一個function，然後create property by function name，然後將ref丟進去，如果存在property就覆蓋。</p>\n</li>\n<li>\n<p>建立scope chain\n想像成一個array或是list，將裡面塞入VO(包涵現在所在的) [bFunc VO, a FuncVO, Global VO]\n(es5會產生global scope, function scope，es6 let會產生block scope)</p>\n</li>\n<li>\n<p>確認this的指向。</p>\n</li>\n</ul>\n<p>最後</p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code>executionContextObj <span class="token operator">=</span> <span class="token punctuation">{</span>\n    scopeChain<span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/* variableObject + all parent execution context\'s variableObject */</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    variableObject<span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/* function arguments / parameters, inner variable and function declarations */</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    <span class="token keyword">this</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment" spellcheck="true">// example</span>\nFuncExecutionContextObj <span class="token operator">=</span> <span class="token punctuation">{</span>\n  activationbj<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n      argumentObj <span class="token punctuation">:</span> <span class="token punctuation">{</span>\n          <span class="token number">0</span><span class="token punctuation">:</span> e<span class="token punctuation">,</span>\n          length<span class="token punctuation">:</span><span class="token number">1</span>\n      <span class="token punctuation">}</span><span class="token punctuation">,</span>\n      a<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">,</span>\n      b<span class="token punctuation">:</span> undefined<span class="token punctuation">,</span>\n      c<span class="token punctuation">:</span> undefined\n      Func<span class="token punctuation">:</span> Pointer to the Function definition<span class="token punctuation">,</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  scopeChain<span class="token punctuation">:</span> <span class="token punctuation">[</span>Func variable object<span class="token punctuation">,</span> Global exection context variable object<span class="token punctuation">]</span><span class="token punctuation">,</span>\n  <span class="token keyword">this</span><span class="token punctuation">:</span> value <span class="token keyword">of</span> <span class="token keyword">this</span>\n<span class="token punctuation">}</span>\n</code></pre>\n      </div>\n<h4>執行階段</h4>\n<p>從上逐步執行每一行code，若是跑到變數宣告才會賦值。</p>\n<p>不過這樣很容易解釋</p>\n<ol>\n<li>var hoisting，因為create stage就已經知道變數了</li>\n<li>var hoisting但呼叫var時為undefined，因為實際給值的動作可能在呼叫之後</li>\n<li>function hoisting但能呼叫，因為function的處理方式是不一樣的</li>\n<li>function expression與function declaration是不一樣的，function declaration視為var 宣告，在執行階段跑到變數宣告才會create function</li>\n</ol>\n<p>寫完文章才理解大家常常在說的上下文是"context"(翻了中英對照才知道...)，實作中比較常會遇到this的指向問題，這邊並沒有多做著磨，我們應該少使用一些反模式就可以大幅減少遇到問題的可能性，像多用es6 module與arrow function就是一種好的寫法(大部份的function不用dynamic this對吧)，有一些this太刁鑽了，想要的看<a href="https://halfrost.com/javascript_this/">這裡</a>。</p>\n<h4>後記</h4>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> c <span class="token operator">=</span> <span class="token string">\'12\'</span><span class="token punctuation">;</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">function</span> <span class="token function">d</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token function">d</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\na<span class="token punctuation">.</span><span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment" spellcheck="true">// {b: ƒ}</span>\n<span class="token comment" spellcheck="true">// 12</span>\n<span class="token comment" spellcheck="true">// Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, frames: Window, …}</span>\n</code></pre>\n      </div>\n<p>\bthis的指向是跟著context的，而讀取變數是跟著scope的，上面範例，在執行d的時候，實際執行者是window，但變數是跟著scope chain所以能讀到c = 12。我發現之前我理解錯誤，我把\bcontext與execution context連想在一起，但在javascript這兩個詞應該是不一樣的(好模糊啊)，execution context是scope VO加上"context"指向的this，所以我認為d是由b執行的，所以該指向execution context的this，但execution context實際上並沒有this的值，只有確認this的綁定。以d()來說，invoke一個unbounded function，其context指向global(\bglobal.d())，而execution context把global存起來，再想到callback形式的寫法( arr.map(function(){ }) )，就能得知其實是一樣的道理。</p>\n<h4>Context vs. Scope</h4>\n<blockquote>\n<p>The first important thing to clear up is that context and scope are not the same. I have noticed many developers over the years often confuse the two terms (myself included), incorrectly describing one for the other. To be fair, the terminology has become quite muddled over the years.</p>\n</blockquote>\n<blockquote>\n<p>Every function invocation has both a scope and a context associated with it. Fundamentally, scope is function-based while context is object-based. In other words, scope pertains to the variable access of a function when it is invoked and is unique to each invocation. Context is always the value of the this keyword which is a reference to the object that “owns” the currently executing code.</p>\n</blockquote>'
}},{node:{fields:{slug:"/posts/browser-mechanic/"},frontmatter:{title:"Browser render & performance",date:"2018-03-25T15:29",tags:["mechanic","performance tuning"],release:!0},html:'<snippet>\n  原本要介紹javascript event loop的，寫一寫變成介紹browserXDD\n</snippet>\n<p>有人問在處理器\bloading js會block render是為什麼，我知道js是single thread，但並不能確定是single thread的問題，於是乎一切要從browser講起。</p>\n<p>modern browser通常是multi process的，自己認為最大的優點是</p>\n<ul>\n<li>避免一頁crash而導致整個browser crash</li>\n<li>避免插件crash而導致整個browser crash</li>\n</ul>\n<p>而對於前端最重要的就是渲染進程(process)，而一個process又可以分成multi thread，而渲染進程裡面擁有的重要thread</p>\n<ul>\n<li>GUI</li>\n<li>JS</li>\n<li>Event</li>\n<li>Timer</li>\n<li>Http request</li>\n</ul>\n<p>GUI與JS \bthread是戶斥的，因為當repaint的時候會觸發GUI \bthread，但JS執行後很有可能會造成多次repaint，於是乎JS在執行的時候會先block GUI thread，待JS結束後才換GUI thread。</p>\n<p>所以如果在browser裡需要做密集運算可以使用web worker，browser會開一個子thread用來處理運算，但是不能操作dom，這是一個很酷的功能，目前的專案有地方可以優化的，只是browser的支援度還不夠所以放棄(IE 11 up...)，希望未來有機會玩囉。</p>\n<p>假設我們發送了一個http request，browser的行為大致如下</p>\n<ol>\n<li>Get content from http request</li>\n<li>Parse html and create dom tree (trigger DOMContentLoaded)</li>\n<li>Parse css and create render tree(with dom tree)</li>\n<li>(Layout/Reflow) the render tree</li>\n<li>Paint the render tree</li>\n<li>Composite &#x26; show on screen (trigger load)</li>\n</ol>\n<p>\n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 590px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 48.701298701298704%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABYlAAAWJQFJUiTwAAABx0lEQVQoz42RTW8TMRCG8/9/BRcuqCduSFUFHJBAtIoKqE2yaTab3dhebzZre7+8+XhwgkqLQMArWfKM7HfmmRkRpJSi73uO4b4fLDb/hG/VOX5U0zRIKbHW8jeNbDHGFN/o/I5+B9ZIkruX2DL6aXgIl8q2rDKF1KGgOxW9xumb3w1FfEkavaYpvzA0S4rsPba4pe1a6m6H1WPa6p629yE+4pxmKz6gxWdyOUEl7zBGoZdv8HXMqHMZtZMslguygBR/fYHKrolThcgLZHRBsbpkaxypNCRrgYivyKYXCCWYz2/JVEn0MCETktEPpCPdcEBtGiazGffzhNL2DHvwvcH7Jhg2JAE5yQqieM1sEZMIE0awpXIeVVTojWXkvefx1G2PcT2u8WFJT/nTwk5nGAZc3ZKKTaApwlybkPv13blDrTVCCOq6htCtrXvyUE2XNa7dUQVcY+yZ5F8aPQ/2YZ1yWzBJVyS6YlOmbOVH6io+47eNxoi3tOWY4/8Y7sKnaB1zt5wwzXIekpgsuWGZRORbT+tWFItX6PSKTRjLQqasyxy/P/zZ8Lm6fo8Nn1wznOdaB3TfWzozxZklorKBZMZKi9D9k+F3wZf7DyYRq4IAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"\n        alt="RenderTree"\n        title=""\n        src="/static/7efd7b826a452eb48175a6d2846a6b1f-a408b.png"\n        srcset="/static/7efd7b826a452eb48175a6d2846a6b1f-4eabf.png 148w,\n/static/7efd7b826a452eb48175a6d2846a6b1f-5a375.png 295w,\n/static/7efd7b826a452eb48175a6d2846a6b1f-a408b.png 590w,\n/static/7efd7b826a452eb48175a6d2846a6b1f-9a0cc.png 885w,\n/static/7efd7b826a452eb48175a6d2846a6b1f-aa987.png 1180w,\n/static/7efd7b826a452eb48175a6d2846a6b1f-c00d7.png 1540w"\n        sizes="(max-width: 590px) 100vw, 590px"\n      />\n    </span>\n  </span>\n  </p>\n<p>原本我知道javascript要放在body之後或是寫上defer，這邊我才發現css也會block render(dom tree ok，但render tree不行)，但是為了first time render，所以css一定要放在head，但如果很大要進行特殊處理，這邊有另一個領域叫critical render path(因為main css屬於critical但\bjs不是，所以js可以慢load)。</p>\n<p>(這就非常有趣了，首先我不知道webpack包裝成的SPA是怎麼處理css的，另外就是css in jsx，loader，styled-Component各會造成怎樣的效果。之後研究的目標之一)</p>\n<p>composite是另一個很有趣的概念，首先要先了解render pipeline</p>\n<p>\n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 590px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 10.91160220994475%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAYAAABYBvyLAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAjklEQVQI12P4eCruPxifToLgkzH/1056+H95z8v/i9pe/l8z6RWYXtz+8v+ynhf/W3dW/W/ZU/q/dkfe/679tf8bdhWCcdPu4v9V27P/M3w8Gf3/49l0KM74/+FYwP/1k27+X9kHMWRl/6v/SzqB9ASQBS/+t21r+N+6t/x/NVBz+95KoGFFQLoKzAaJAQCwJ3VdTiSw7wAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"\n        alt="render_pipeline"\n        title=""\n        src="/static/18578f2ae7d686d16ac1ea1bc606f83c-a408b.png"\n        srcset="/static/18578f2ae7d686d16ac1ea1bc606f83c-4eabf.png 148w,\n/static/18578f2ae7d686d16ac1ea1bc606f83c-5a375.png 295w,\n/static/18578f2ae7d686d16ac1ea1bc606f83c-a408b.png 590w,\n/static/18578f2ae7d686d16ac1ea1bc606f83c-9a0cc.png 885w,\n/static/18578f2ae7d686d16ac1ea1bc606f83c-aa987.png 1180w,\n/static/18578f2ae7d686d16ac1ea1bc606f83c-52bff.png 1448w"\n        sizes="(max-width: 590px) 100vw, 590px"\n      />\n    </span>\n  </span>\n  </p>\n<p>在前端的渲染機制是這樣</p>\n<ul>\n<li>Javascript - trigger event</li>\n<li>Style - css selector</li>\n<li>Layout - calculate Layout</li>\n<li>Paint - fill pixel</li>\n<li>Composite - layer merge</li>\n</ul>\n<p>只介紹後面三個，跟頁面排版有關的東西會重新計算(width, height, left...)，此種行為觸發layout，跟繪制有關的觸發paint(color, border...)，跟layer有關的觸發composite，這是一個pipeline，但不是每一個都要經過，經過越少step的效能越好。而通常在一個沒有特別設置的頁面只會有一個layer(或是browser預設的layer?待求證)，但我們可以用tranform, translate 3d, will-change等去特別制造一個layer出來，最後composite的時候就會組合起來。所以就以純移動來講，使用tranform(\bStyle -> Composite)比left(\bStyle -> Layout -> Paint -> Composite)好，但實際使用一個頁面太多layer反而會降低效率，所以這又很吃應用場景。</p>\n<p>當你修改了某些css的style，會產生不同的cost。這邊有份<a href="https://www.slideshare.net/ApoorvSaxena/performance-beyond-page-load">簡報</a>，甚至你可以到<a href="https://csstriggers.com/">css trigger</a>查詢。</p>\n<p>(這邊也非常有趣，沒有實際優化過，不過用過一兩次will-change)</p>\n<p>PS. 其實大部份的概念來自<a href="http://www.dailichun.com/2018/01/21/js_singlethread_eventloop.html">這篇文章</a>，建議好好的看過文章，因為我的版本省略了很多介紹XD</p>\n<p>不過以上介紹的東西在現代的前端開發(SPA component...)還需要再釐清，很多都是3-4年前的推廣，像是css建議多用class而不要js控制，但jsx推崇css in js，另外在render部份使用vdom技術，加上使用webpack打包會不會已經不用關注某些問題值得再討論。</p>'}},{node:{fields:{slug:"/posts/new-year-wish/"},frontmatter:{title:"New Year Wish",date:"2018-02-20T18:06",tags:["nothing special"],release:!0},html:'<snippet>\n  新年到了，該給自己一個目標。\n</snippet>\n<p>原本是想要每個月寫一篇文章的，但是人都有惰性(\bx)。</p>\n<p>最近也在凖備轉職，從面試中也得知了許多自己的不足，雖然我知道這些問題可能都是拿來壓薪水的XD</p>\n<p>近期也幫了公司導入unit test，因為要做教育訓練，也花了時間做投影片。從那些似曾相似的題目，從為了教育訓練而認真研究，能了解到一件事情。會用跟知道原理完全是兩回事，很多時候就覺得就是這樣，但說不出個所以然，感覺就很javavscript，因為javascript就是一個這麼不嚴格的語言XD</p>\n<p>import module用慣了，套件用久了，react寫多了，這麼的declative，反而造成了只知道怎麼用，而不知道原因。目前短期先把javascript的重要概念先補完吧，同時想要解決兩件事情，第一，當有人問起時，可以完整的告知原因，而不是隨便呼嚨兩句，第二，也是我最一開始的理想，把那些常忘記的事情記錄，會常忘記就是因為每次都好像是這樣，大概是這樣。</p>\n<p>這次增加了一頁TODO LIST，不記錄一下，我連想寫什麼文章都要忘了。</p>\n<p>原本的夢想是成為一個優秀的前端工程師，開著chrome dev tools，為使用者的0.01秒而奮鬥，但是在台灣的工作中好像沒有看過，大部份都是開發速度導向，當然我開發上也還有進步的空間，不過今年看到印象最深刻的還是react 0.16頁面中的<a href="https://medium.com/@paularmstrong/twitter-lite-and-high-performance-react-progressive-web-apps-at-scale-d28a00e780a3">twitter PWA tunning</a>。</p>\n<p>當然新年還是要玩一些新東西，還在想要朝向isomorphic還是react-native邁進。react-native比起以前已經相對的成熟了，通常做app更講究使用者體驗，也是我更有興趣的一部份，但是fullstack在職涯上有絕對的優勢，自己寫過過往的full stack mvc，也改過公司後台的nodejs(refactor一些東西)，非常不認同前端是比較簡單的工作(薪水比較低)，只是注意的點是不一樣的，我更在意的是使用者會如何跟我的介面互動，這就好像設計不值錢這種謬論是一樣的。</p>\n<p>最後，今年應該是兩個都會碰一下，不過主要玩isomorphic &#x26; backend相關技術，這與我幾年後的目標比較match，當然最終可以react-native + isomorphic，等到時候再說吧，前端技術，每18個月重來一次呢。</p>'}},{node:{fields:{slug:"/posts/react-setstate-2/"},frontmatter:{title:"React的setState非同步行為2",date:"2018-01-16T10:33",tags:["react","javascript"],release:!0},html:'<snippet>\n都2018了，現在的感覺是redux統一天下。不過在清書籤頁，希望是近期內最後一次深入了解state。\n</snippet>\n<p>因為state的改變會觸發re-render，而re-render是一個expensive的行為，所以React做了batch，在一連串state改變中只會render一次。</p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n    something<span class="token punctuation">:</span> thisThing<span class="token punctuation">,</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>condition<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n      something<span class="token punctuation">:</span> thatThing<span class="token punctuation">,</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n      </div>\n<p>有時候就是會寫出這種code(尤其是在lifecyle componentWillReceiveProps之類的)</p>\n<p>但因為非同步所以會拿到不對的state值，所以大家很喜歡在這事上討論(打轉)。</p>\n<h4>常見解決辨法</h4>\n<ol>\n<li>\n<p>update完成後，callback，看<a href="https://ernieyang09.github.io/posts/react-setstate/">這裡</a></p>\n</li>\n<li>\n<p>校正lifecyle，在正確的lifecycle裡面呼叫setState。</p>\n</li>\n</ol>\n<p>3\b. 直接呼叫callback，介紹一下</p>\n<p>\bsetState是可以直接帶入一個callback的</p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">(</span>prevState<span class="token punctuation">,</span> currentProps<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  reurn <span class="token punctuation">{</span> prevState<span class="token punctuation">,</span> something<span class="token punctuation">:</span> currentProps<span class="token punctuation">.</span>something <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n      </div>\n<p>不過這一點都不能解決非同步state問題(還是會拿到舊的state)</p>\n<p>很認真的看了<a href="https://medium.com/@wereHamster/beware-react-setstate-is-asynchronous-ce87ef1a9cf3">文章</a>以後，我是覺得結論有點難懂</p>\n<p>，結論是說，將function移出class會讓需要修改的值變得更明確(agree)。但是仍然有小機率會用到舊的state(這邊不太理解小機率\b...)</p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">incrementFooBy</span><span class="token punctuation">(</span>delta<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token punctuation">(</span>previousState<span class="token punctuation">,</span> currentProps<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> <span class="token punctuation">{</span> <span class="token operator">...</span>previousState<span class="token punctuation">,</span> foo<span class="token punctuation">:</span> previousState<span class="token punctuation">.</span>foo <span class="token operator">+</span> delta <span class="token punctuation">}</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">class</span> <span class="token class-name">MyComponent</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>\n    onClick <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token function">incrementFooBy</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span>onClick<span class="token punctuation">}</span><span class="token operator">></span>click me<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n      </div>\n<p>不過最大的變數應該是react setstate行為以後可能會全部重新定義吧。</p>\n<p>截錄另一篇<a href="http://vwangluo.com/article/detail/42214">文章</a>兩段話</p>\n<blockquote>\n<p>Honestly, the current batching strategy comes with a set of problems right now. I\'m hesitant to expand on it\'s API before we\'re sure that we\'re going to keep the current model. I think of it as a temporary escape until we figure out something better.</p>\n</blockquote>\n<p>問題的根源在於現有的 batching 策略，實話實說，這個策略帶來了一系列問題。也許這個在後期後有調整，在 batching 策略是否調整之前，盲目的擴充 setState 接口只會是一個短視的行為。</p>\n<blockquote>\n<p>In my experience, whenever I\'m tempted to use setState callback, I can achieve the same by overriding componentDidUpdate (and/or componentDidMount).</p>\n</blockquote>\n<p>對此，Redux 原作者 Dan Abramov 也發表了自己的看法。他認為，以他的經驗來看，任何需要使用 setState 第二個參數 callback 的場景，都可以使用生命周期函數 componentDidUpdate (and/or componentDidMount) 來覆寫。</p>\n<p>如果確認專案是使用redux flux等，state只用來處理一小部份short-time data，那我是覺得真正遇到問題的時候再研究啦。</p>'}},{node:{fields:{slug:"/posts/circular-dependency-plugin/"},frontmatter:{title:"Circular Dependency Plugin",date:"2018-01-15T15:25",tags:["webpack"],release:!0},html:'<snippet>\n之前在build的時候遇到的問題，主要就是開發的時候完全沒問題，但是在build的時候會發生error，error的畫面我忘記截圖了。最後的結果是import的順序有重復。\n</snippet>\n<p>Circular Dependency最常見的錯誤</p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code><span class="token comment" spellcheck="true">// A.js</span>\n<span class="token keyword">import</span> B <span class="token keyword">from</span> <span class="token string">\'./B\'</span><span class="token punctuation">;</span>\n\n<span class="token comment" spellcheck="true">// B.js</span>\n<span class="token keyword">import</span> C <span class="token keyword">from</span> <span class="token string">\'./C\'</span><span class="token punctuation">;</span>\n\n<span class="token comment" spellcheck="true">// C.js</span>\n<span class="token keyword">import</span> A <span class="token keyword">from</span> <span class="token string">\'./A\'</span><span class="token punctuation">;</span>\n\n<span class="token comment" spellcheck="true">// A -> B -> C -> A</span>\n</code></pre>\n      </div>\n<p>常常發現\bimport之後<a href="https://stackoverflow.com/questions/35240716/webpack-import-returns-undefined-depending-on-the-order-of-imports">拿到undefined</a></p>\n<p>專案中我將網頁的router抽出來整理(router.js，裡面有import所有router用的component)，然後對每個頁面包覆Page component。</p>\n<p>Like this</p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code><span class="token keyword">import</span> routers <span class="token keyword">from</span> <span class="token string">\'./routers\'</span><span class="token punctuation">;</span>\n\n<span class="token operator">...</span>\n\n<span class="token punctuation">{</span>\n  routers<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>router <span class="token operator">=></span><span class="token punctuation">(</span>\n    <span class="token operator">&lt;</span>Route\n      path<span class="token operator">=</span><span class="token punctuation">{</span>router<span class="token punctuation">.</span>path<span class="token punctuation">}</span>\n      component<span class="token operator">=</span><span class="token punctuation">{</span>router<span class="token punctuation">.</span>component<span class="token punctuation">}</span>\n    <span class="token operator">/</span><span class="token operator">></span>\n  <span class="token punctuation">)</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">class</span> <span class="token class-name">SomePage</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>\n  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token punctuation">(</span>\n        <span class="token operator">&lt;</span>Page<span class="token operator">></span>\n          <span class="token operator">...</span>\n        <span class="token operator">&lt;</span><span class="token operator">/</span>Page<span class="token operator">></span>\n    <span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n      </div>\n<p>其中，Page component裡面寫了一個Breadcrumb，Breadcrumb理所當然跟router有關，所以我就在Breadcrumb import routers，開發時完全沒問題，build的時候就爆炸啦XD</p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code>index <span class="token operator">-</span><span class="token operator">></span>  routers <span class="token operator">-</span><span class="token operator">></span> Page <span class="token operator">-</span><span class="token operator">></span> Breadcrumb <span class="token operator">-</span><span class="token operator">></span> routers\n</code></pre>\n      </div>\n<p>這種重覆import的例子並不是只要有任何的寫到就會出錯，是一種機率性的，就像有時候build起來的css跑掉了，可能是import了某個module(但不一定有用到css)，造成webpack build的時候順序不一樣了，這種build的時候才會出現問題的最麻煩了。</p>\n<p>不過了解了這個問題之後，google了一下，有一個webpack plugin - <a href="https://github.com/aackerman/circular-dependency-plugin">Circular Dependency Plugin</a></p>\n<p>能在runtime的時候，發現重覆import的問題，直接不能執行，並且show出哪些文件有問題，我個人是覺得蠻好用的。</p>\n<p>最後我的作法是把index跟Breadcrumb load的router切開來寫成兩個檔案，只是以mainatin上就要保持兩邊一致(加入新的\broute，兩邊都要設計一遍)，目前還沒想到比較好的做法，不過這要看專案設計囉。</p>'}}]}},pathContext:{offset:0,paginations:6,total:24}}}});
//# sourceMappingURL=path---index-0d04d0bbe4dd63639200.js.map